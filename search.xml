<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《算法图解》学习笔记]]></title>
    <url>%2F2019%2F09%2F29%2FAlgorithm%2F</url>
    <content type="text"><![CDATA[一、二分法使用二分法时，输入一定是有序列表。python实现： 1234567891011121314151617def Binary_search(list, item): low = 0 high = len(list) - 1 while low&lt;=high: mid = (low + high) // 2 # 结果自动向下取整 if list[mid] == item: return mid if item &lt; list[mid]: high = mid - 1 else: low = mid + 1 return Nonemy_list = [2,3,4,6]print(Binary_search(my_list,2))print(Binary_search(my_list,1)) C++ 实现 1234567891011121314151617181920212223void Binary_search(int a[],int len,int item)// void Binary_search(int*a, int len, int item)&#123; int low = 0; int high = len - 1; int mid = 0; while (low&lt;=high) &#123; mid = (high + low)/2; if (a[mid] == item) &#123; printf("a[%d] = %d\n",mid,item); break; &#125; if (item &lt; a[mid]) high = mid -1; else low = mid + 1; &#125; if (a[mid] != item) printf("数组不包含元素 %d\n",item);&#125; 二、选择排序选择排序的思想是每次选择最小的数字，需要遍历（n-1）次，需要比较（n-1）次。python实现 123456789101112131415def findSmallest(arr): smallest = arr[0] smallest_index = 0 for i in range(1,len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_indexdef SelectionSort(arr): newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) newArr.append(arr.pop(smallest)) return newArr C++ 实现 12345678910111213141516void SelectionSort(int* a,int l)&#123; int t,i,j; for(i=0;i&lt;l-1;i++) &#123; for(j=i+1;j&lt;l;j++) &#123; if (a[j]&lt;a[i]) // 按从小到大排序 &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; &#125;&#125; 三、分而治之3.1 数组求和输入一个数组 —&gt; 如果数组为空，则返回0 —&gt; 否则计算列表中除第一个数之外的其他数的和，再将其与第一个数相加，返回结果。python 实现 12345def sum(list): if list == []: return 0 else: return list[0] + sum(list[1:]) 3.2 编写递归函数计算列表包含的元素个数输入列表 —&gt; 如果列表为空，则长度为0 —&gt; 否则计算列表除第一个元素之外的元素个数python 实现 12345def count(list): if list ==[]: return 0 else: return 1 + count(list[1:]) 3.3 找出列表中最大的数输入列表 —&gt; 如果列表只包含两个元素，则直接比较大小，输出较大值 —&gt; 否则递归计算除列表第一个元素之外的较大值与列表第一个值进行比较，输出结果python 实现 123456789101112def max(list): if len(list) == 2: # 基线条件 if list[0] &gt; list[1]: return list[0] else: return list[1] else: sub_max = max(list[1:]) if list[0] &gt; sub_max: return list[0] else: return sub_max 12345def max(list): if len(list)==2: return list[0] if list[0] &gt; list[1] else list[1] sub_max = max(list[1:]) return list[0] if list[0] &gt; sub_max else sub_max 3.4 二分查找二分查找也是一种分而治之的算法，基线条件是数组只有一个元素，如果查找的值与这个元素相同，则找到了，如果不相同，则数组中不包含该值。递归条件中，将数组分为两半，将其中一半丢弃，对另一半进行二分查找。 四、快速排序算法快速排序算法采用了分而治之的思想，原理是： 基准条件：数组没有元素或只有一个元素时，不需要进行排序 首先选择一个基准值； 将数组中其他值与基准值比较，大于基准值的数组成一个数组，小于基准值的数组成一个数组； 分别对两个数组进行快速排序。python 实现12345678def quickSort(list): if len(list)&lt;2: return list else: pivot = list[0] less = [i for i in list[1:] if i&lt;pivot ] greater = [i for i in list[1:] if i&gt;pivot ] return quickSort(less) + [pivot] + quickSort(greater) C++ 实现 难点C++数组长度固定，选取基准值之后，需要遍历数组，将其分为两部分，调整基准值的位置。 1234567891011121314151617181920212223242526272829int partition(int* arr,int left,int right)&#123; int i = left + 1; // less int j = right; // right int temp = arr[left]; // temp 为选取的基准值 // 遍历数组，找到小于基准值和大于基准值的数 while(i &lt;= j) &#123; while( arr[i] &lt; temp ) i++; while( arr[j] &gt; temp ) j--; if( i &lt; j) swap(arr[i++],arr[j--]); else i++; // i=j 为了跳出循环 &#125; swap(arr[j],arr[left]); return j;&#125;void quickSort(int* arr,int left,int right)&#123; if (left&gt;right) return; int j = partition(arr,left,right); quickSort(arr,left,j-1); quickSort(arr,j+1,right);&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[matlab]]></title>
    <url>%2F2019%2F09%2F18%2Fmatlab%2F</url>
    <content type="text"><![CDATA[一、读取某个文件夹下的所有文件12testfilepath = &apos;./test/&apos; % 指定文件夹地址testfile = dir()]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logistic 回归]]></title>
    <url>%2F2019%2F09%2F16%2FLogistic%2F</url>
    <content type="text"><![CDATA[Sigmoid函数和Logistic回归分类器 最优化理论初步 梯度下降最优化算法 数据中的缺失项处理 #]]></content>
      <categories>
        <category>Machine-Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCA]]></title>
    <url>%2F2019%2F09%2F16%2FPCA%2F</url>
    <content type="text"><![CDATA[一、在Numpy中实现PCA将数据转换成前N个主成分的伪代码： 去除平均值 计算协方差矩阵 计算协方差矩阵的特征值和特征向量 将特征值从大到小排序 保留最上面的N个特征向量 将数据转换到上述N个特征向量构建的新空间中 二、示例：利用PCA对半导体制造数据降维数据中的缺失项处理 使用可用特征的均值来填补 使用特殊值来填补，如-1，0 忽略有缺失值的样本 使用相似样本的均值来填补缺失值 使用另外的机器学习方法来预测缺失值]]></content>
      <categories>
        <category>Machine-Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something To Think About]]></title>
    <url>%2F2019%2F09%2F08%2Fsomething-to-think-about%2F</url>
    <content type="text"><![CDATA[似乎越来越没有勇气去面对不完整和不完美。 所谓真实，就是你看到什么，听到什么，做什么，和谁在一起，有一种从心灵深处满溢出来的不懊悔，也不羞耻的平和与喜悦。 —— 梅贻琦 两年前，我还是一个自认为精神世界很富足的人。我可以不顾一切去做自己想做的事，不去考虑任何后果地去做当下自认为正确、且不做一定会后悔的事；我不会花心思去考虑”将来”，不去想将来我会沦落成什么样子，将来的我会如何被现实踩在脚下；我关心当下，害怕错过当下的每一个可以让我感到快乐、让我拥有丰富经历的机遇；我时常重温过去，想在自己已有的经历中提炼一个自我的价值观，尽管这个价值观不完整、狭隘、幼稚、不堪一击，但我毫不质疑地相信并珍视它，因为它是我一遍又一遍推翻、重塑取得的，它对我来说绝对真实。我相信美好多于邪恶，光明大于黑暗，我尽可能聆听而不是表达，旁观而不去插手。我以为，我可以做自己的灯塔，我以为我获得了实实在在的成长，我以为一束光哪怕再虚弱也值得努力去相信和守护。 母亲站在路口提醒我不要去走，但是我终究走了这条路，荆棘丛生，令人受伤。走完路，我站在路口，提醒别人不要走。 ———— 张爱玲 可现在发现不一样了。我必须承认，迷茫、焦虑和”丧”像蓄谋已久的暗势力一点点蚕食着我努力维系和相信的平衡与价值，一点点在我的精神世界蔓延，只是这个我一直在为自己找借口搪塞的事实，在我面临当下这个选择时被暴露无遗。选择做一个和所谓老道的“过来人”们、和未知的残酷现实对抗的“年轻人”，也让自己成为了这个机遇与风险相斥相生、呼啸前行的时代洪流中最最单薄的个体。 在这个时代成长的青年人和上一代不一样，他们已经不用背负民族的历史使命，因为达到“国富民强”这个目标的距离已经不远了。这意味着“过去”虽然还是令人沉痛，但今天的丰足足以让我们乐观地活下去。“历史”也不再沉重，慢慢地变得轻了。当然，这并不代表“今天”就可以活得容易轻松。在缺少兴邦立业的理想和“唯一”的宗教（精神）信仰的指导下，青年人只能向内探索，以寻找自我存在的意义，并借此彰显所谓“光宗耀祖”的想法。不幸的是，经济发展所带来的转变是个人难以预计的，人生计划往往跟不上环境的变化。而且，国家市场的强大也使中国社会赖以维系和凝聚的家庭结构及其核心价值日渐崩坏，致使后者的重要性在牵涉实际利益的情况下才能被体现出来。结果，在“将来”难以想象的情况下，我们只能选择面对“现实”：出身环境不好的只能听天由命；出身较好的就努力维持自身的利益。这个情况就好像那个“狮子追人”的故事：一只凶猛的狮子往人群里奔跑想要把人吃掉充饥。一些较为年青的人就想，只要比其他人跑得更快，就不会被狮子吃掉了。可惜的是，当狮子再次感到饥饿的时候，他们其中一个总会成为跑得最慢的人，直到所有人都被吃光为止。在人生充满偶然的情况下，我们该如何自处，有没有合力击退狮子的可能呢？ （emmm….我不是gd,立场绝对是“中国一点都不能少”，我也不完全认同这篇致谢辞中的观点，只是觉得有一、、道理。）昨天去世博馆参观，看着挂在墙上的连环画《山乡巨变》和《清明上河图》，越发觉得个体真的太渺小了，无论从时间上还是空间上。我们这一代与上一代、上上一代是不一样的，我们这一代脱离了物资匮乏时代的生存需求，但我们也实实在在少了一份有价值的、能够赋予我们安全感和归属感的纯粹。在信息爆炸的当下，我们成了没有信仰的游牧者，成了在泥沙俱下的网络信息中获取认同感的卑微者。 于是，我努力守护的光没有成为我对抗现实的勇气，反而成为了我只想紧握在手心、再也不愿示人的软肋。]]></content>
      <tags>
        <tag>Experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面向对象程序设计]]></title>
    <url>%2F2019%2F09%2F06%2FCpp5%2F</url>
    <content type="text"><![CDATA[理解类和对象的概念 定义并实例化类对象 实现运算符重载 理解多重集成和嵌套类 定义和使用类模板 编写异常处理语句 一、类和对象面向对象最大的特征就是提出了类和对象的概念。将遇到的各种事物抽象为类，类中包含数据和操作数据的方法，用户通过实例化类对象来访问类中的数据和方法。1.1 类的定义类的定义包含两部分，类头和类体。其中，类头由class关键字和类名构成，类体由一组大括号{}和;构成，类体中定义了类的数据和方法，数据描述了类的特征（也称为类的属性）；方法是类中定义的函数，描述的是类的行为。 类的定义class 类名{ 定义数据、方法;};数据 — 类的属性/特征；方法 — 类的行为。 定义类成员变量时不要直接对类成员初始化 不要忘记最后的分号;e.g 定义一个CUser类。12345678910111213141516171819class CUser&#123; char m_Username[128]; char m_Password[128]; // char m_Paeeword[128] = &#123;0&#125;; // 错误，不可以直接初始化 bool Login() &#123; if(strcmp(m_Username,"MJ")==0 &amp;&amp; strcmp(m_Password,"KJ")==0) &#123; printf("登录成功！\n"); return true; &#125; else &#123; printf("登录失败！\n"); return false; &#125; &#125;&#125;; // 不要忘记; 1.2 类成员的访问C++提供了3个访问限定符用于标识类成员的访问，分别为public、protected和private。 public成员，公有成员，可以在程序的任何地方进行访问； protected成员，保护成员，只有在该类和该类的派生类中进行访问； private成员，私有成员，只能在类中访问。定义类时未指定访问限制符，则默认为private。e.g 重新定义CUser类，将各成员设置为不同的访问级别。123456789101112131415161718192021222324252627282930313233343536373839class CUser&#123;private: // 私有成员定义 char m_Username[128]; char m_Password[128];public: // 公有成员定义 void SetUsername(const char *pUsername) &#123; if(pUsername != NULL) strcpy(m_Username,pUsername); &#125; char* GetUsername()const // 该方法使用了const, //说明在定义该方法时不能修改类成员变量 &#123; return (char*)m_Username; &#125; void SetPassword(const char* pPassword) &#123; if(pPassword != NULL) strcpy(m_Password,pPassword); &#125; char* GetPassword()const &#123; return (char*)m_Password; &#125; bool Login() &#123; if(strcmp(m_Username,"MJ")==0 &amp;&amp; strcmp(m_Password,"KJ")==0) &#123; printf("登录成功！\n"); return true; &#125; else &#123; printf("登录失败！\n"); return false; &#125; &#125;&#125;; 不能在const方法中修改数据成员，如果方法中包含指针成员，在const方法中也不可以重新为指针赋值，但是可以修改指针所指向地址中的数据。对象，类的实例化，当程序中定义一个类时，并没有为其分配存储空间，只有当定义类的对象时，才分配存储空间。 123456CUser user; // 定义一个对象user.SetUsername("MR"); // 调用CUser类的SetUsername 方法user.SetPassword("JK"); user.Login();// 类成员是有访问权限的，不可以在类外部访问私有或受保护的成员strcpy(user.m_Username,"KJ"); // 错误，不可以在类外访问private成员 在定义类对象时，可以将其声明为一个指针。 1CUser *user; 也可以使用new来为指针分配内存。 123CUser *pUser = new CUser;// 或Cuser *pUser = new CUser(); 指针型类对象使用运算符“-&gt;“来访问类成员。 12345CUser *user = new CUser(); // 定义一个对象指针，并为其分配内存user -&gt; SetUsername("MR");user -&gt; SetPassword("JK");user -&gt; Login();delete user; // 释放为对象指针分配的内存 如果将类对象定义为常量指针，则对象只允许访问const方法。 1234const CUser *user = new CUser();user -&gt; GetUsername();user -&gt; GetPassword();delete (CUser *)pUser; // 释放常量指针 1.3 构造函数和析构函数 每个类都有构造函数和析构函数，构造函数在定义对象时被调用，析构函数在对象释放时被调用； 如果用户没有提供构造、析构函数，系统会提供默认的构造、析构函数。1.3.1 构造函数构造函数是一个与类同名的方法，可以没有参数、有一个参数或多个参数，但是构造函数没有返回值。如果构造函数没有参数，该函数被称为类的默认构造函数。e.g 显式地定义一个默认构造函数。1234567891011121314151617181920class CUser&#123;private: char m_Username[128]; // 定义数据成员 char m_Password[128];public: CUser() // 定义默认构造函数 &#123; strcpy(m_Username,"MR"); // 为数据成员赋值 strcpy(m_Password,"KJ"); &#125; char* GetUsername()const &#123; return(char*) m_Username; &#125; char* GetPassword()const &#123; return(char*) m_Password; &#125;&#125; 如果用户为类定义了构造函数，无论是默认构造函数还是带参的非默认构造函数，系统均不会提供默认的构造函数。定义一个CUser对象，它将调用定义的构造函数。 1234567int main()&#123; CUser user; printf("Username = %s\n",user.GetUsername); printf("Password = %s\n",user.GetPassword); return 0;&#125; e.g 定义一个非默认构造函数，使得用户能够在定义CUser对象时为数据成员赋值。 12345678910111213141516171819202122232425262728class CUser&#123;private: char m_Username[128]; // 定义数据成员 char m_Password[128];public: CUser() // 定义默认构造函数 &#123; strcpy(m_Username,"MR"); // 为数据成员赋值 strcpy(m_Password,"KJ"); &#125; CUser(const char *pUsername,const char *pPassword) // 定义非默认构造函数 &#123; if(pUsername!=NULL &amp;&amp; pPassword!=NULL) &#123; strcpy(m_Username,pUsername); strcpy(m_Password,pPassword); &#125; &#125; char* GetUsername()const &#123; return(char*) m_Username; &#125; char* GetPassword()const &#123; return(char*) m_Password; &#125;&#125;; 分别调用两个构造函数。 12345678int main()&#123; CUser user; printf("%s\n",user.GetUsername()); CUser customer("SK","songkun"); printf("%s\n",customer.GetUsername()); return 0;&#125; 定义一个CUser对象指针，并调用非默认构造函数进行初始化。 1CUser *user = new CUser("SK","songkun"); // 调用非默认构造函数为指针分配空间 在定义常量或引用时，需要同时进行进行初始化。 但是在类中定义数据成员时，为其直接赋值是非法的。因此，类的构造函数通过使用”:”运算符提供了初始化成员的方法。 12345678910111213class CBook&#123;public: char m_BookName[128]; // 定义数据成员 const unsigned int m_Price; int m_ChapterNum; CBook() // 定义默认构造函数 :m_Price(32),m_ChapterNum(15) // 初始化数据成员，注意，末尾没有; &#123; strcpy (m_BookName,"大学英语"); &#125;&#125;; 1.3.2 复制构造函数 编译器还可以提供默认的复制构造函数。当函数或方法的参数采用值传递时，编译器会将实际参数复制一份传递到被调用函数中，如果参数属于某一个类，编译器会调用该类的复制构造函数来复制实际参数到被调用函数； 复制构造函数与类同名，且只有一个参数，为类的常量引用类型（const 类名 &amp;引用名）。 复制构造函数复制构造函数的目的即当类对象为函数的参数时，为函数复制实际参数，且没有必要在复制构造函数中修改参数，因此参数定义为常量。 e.g 定义复制构造函数。123456789101112131415161718192021class CBook&#123;public: char m_BookName[128]; // 定义数据成员 const unsigned int m_Price; int m_ChapterNum; CBook() // 定义默认构造函数 :m_Price(32),m_ChapterNum(15) &#123; strcpy (m_BookName,"大学英语"); printf("构造函数被调用。\n"); &#125; CBook(const CBook &amp;book) :m_Price(book.m_Price) &#123; m_ChapterNum = book.m_ChapterNum; strcpy(m_BookName,book.m_BookName); printf("复制构造函数被调用。\n"); &#125;&#125;; 以CBook类对象为参数，演示在按值传递函数参数时调用复制构造函数。 12345678910void OutputBook(CBook book) // 以类对象作为参数，且为“值传递”&#123; printf("Book's price is %d\n",book.m_Price);&#125;int main()&#123; CBook book; OutputBook(book); return 0;&#125; 输出构造函数被调用。复制构造函数被调用。Book’s price is 32. 当函数参数按引用的方式传递时，直接将实际参数的地址传递给函数，不涉及复制参数，因此没有必要调用复制构造函数。 12345// 以引用类型作为函数参数void OutputBook(CBook &amp;book)&#123; printf("Book's price is %d\n",book.m_price);&#125; 经验编写函数时，尽量按引用的方式传递类对象参数，这样可以避免调用复制构造函数，极大地提高了程序的执行效率。 1.3.3 析构函数 析构函数在对象唱出作用范围或使用delete运算符释放对象时被调用，用于释放对象占用的空间； 如果用户没有显示地提供析构函数，系统会自动生成； 析构函数名与类名相同，使用”～“标识其为析构函数； 析构函数没有参数，不能被重载。e.g 定义析构函数。123456~CBook()&#123; m_ChapterNum = 0; memset(m_BookName,0,128); // 设置成员变量的存储空间数据为0 printf("析构函数被调用\n");&#125; 析构函数调用如果以类的对象作为某函数的参数，且是值传递在函数返回前，释放形参空间，调用析构函数。如果是引用传递，则只是在主函数执行结束前释放对象，调用析构函数。 1234567891011void OutputBook(CBook book)&#123; printf("Book's price is %d\n",book.m_Price);&#125;int main(int argc,char* argv[])&#123; CBook book; printf("book's price = %d\n",book.m_Price); OutputBook(book); return 0 ;&#125; 输出构造函数被调用。book’s price = 32复制构造函数被调用。Book’s price is 32析构函数被调用 // 释放值传递的形参对象，调用析构函数（如果函数为值传递CBook &amp;book,则不需要调用析构函数）析构函数被调用 // 主函数结束前释放对象，调用析构函数 void memset(type *s,int v,size_t n)s – 也可以是数组名；v – 要填充的值；n – 要填充的字节数；https://www.cnblogs.com/yhlboke-1992/p/9292877.html 1.4 内联函数在定义类的成员函数时，也可以使用inline关键字将成员函数定义为内联成员函数。对于成员函数来说，如果其定义是在类体中，即使没有使用inline关键字，该成员函数也被认为是内联函数。e.g.1 定义内联成员函数成员函数的定义在类体内。 1234567891011class CUser&#123;private: char m_Username[128]; char m_Password[128];public: char* GetYsername()const // 函数定义在类体内，为内联成员函数 &#123; return （char*)m_Username; &#125;&#125; e.g.2 使用inline关键字定义内联函数。 1234567891011121314class CUser&#123;private: char m_Username[128]; char m_Password[128];public: char* GetUsername()const; // inline char* GetUsername()const; &#125;inline char* CUser::GetUsername()const // inline关键字可以使用在定义处， // 也可以使用在声明处&#123; return (char*)m_Username;&#125; 程序会在调用内联函数时直接插入函数代码，如果函数语句较多，将会导致程序代码膨胀。如果将析构函数定义为内联函数，则可能导致潜在的代码膨胀，因为以类对象作为函数参数时，每次函数调用完都需要释放对象，调用析构函数。 1.5 静态类成员 使用关键字static定义静态类成员 静态类成员允许使用类名直接访问 通常在类体外部对静态数据成员进行初始化 在一个类中，静态数据成员是被所有的类对象共享的，无论定义多少个类对象，类的静态数据成员只有一份，同时，如果某一个对象修改了静态数据成员，其他对象的静态数据成员（实际上是一个静态成员）也会被修改。12345678910111213141516class CBook&#123;public: static unsigned int m_Price; // 定义一个静态数据成员&#125;unsigned int CBook::m_Price = 10; // 静态数据成员初始化int main()&#123; CBook book，vcbook; printf("%d\n",book.m_Price); // 使用对象访问静态数据成员 printf("%d\n",CBook::m_Price); // 使用类名访问静态数据成员 book.m_Price = 20; printf("%d\n",vcbook.m_Price); // 20,所有对象公用一份静态数据成员 return 0;&#125; 对于静态数据成员，需要注意： 静态数据成员可以是当前类的类型，而其他数据成员只能是当前类的指针或引用类型。 12345678class CBook&#123;public: static unsigned int m_Price; CBook m_Book; // 非法定义，不允许在类中定义所属类的对象 static CBook m_VCbook; // 正确，静态数据成员可以被定义为所属类的对象 CBook *m_pBook; // 正确，允许定义类的所属类的指针类型对象&#125; 静态数据成员可以作为成员函数的默认参数，普通数据成员不可以。 123456789101112131415class CBook&#123;public: static unsigned int m_Price; int m_Pages; void OutputInfo(int data= m_Price) // 定义一个成员函数，以静态数据成员作为其默认参数 &#123; printf("%d\n",data); &#125; void OutputPage(int page = m_Prages) // 非法定义，类的普通数据成员不能作为其默认参数 &#123; printf("%d\n",page); &#125;&#125; 类的静态成员函数：使用static关键字定义类的静态成员函数。类的静态成员函数只能访问类的静态数据成员，而不能访问普通的数据成员；静态数据成员不能定义为const成员函数，即末尾不能加const关键字；静态数据成员函数的定义必须在类体内 1234static void CBook::OutputInfo() // 非法，不可以在类体外定义类的静态成员函数&#123; printf("%d\n",m_Price);&#125; 1.6 隐藏的this指针同一个类的不同对象都有自己的非静态数据成员和成员函数。在每个类的成员函数（非静态成员函数）中都隐含一个this指针，指向被调用对象的指针，其类型为当前类的指针类型（在const方法中，为 当前类的const指针类型）。用户可以显式的使用this指针访问数据成员。 1234void OutputInfo()&#123; printf("%d\n",this-&gt;m_Pages); // 使用this指针访问数据成员，this指向当前调用该函数的对象&#125; 编译器为了实现this指针，在成员函数中自动添加了this指针用于对数据成员或方法的访问；为了将this指针指向当前调用对象，并在成员函数中能够使用，在每个成员函数中都隐藏包含一个this指针作为函数参数，并在函数调用时将对象自身的地址隐含作为实际参数进行传递。 1234void OutputInfo(CBook *this) // 隐含添加this指针作为函数参数&#123; printf("%d\n",this-&gt;m_Price);&#125; 1.7 运算符重载运算符重载是C++的一个重要特性，允许用户对一些编译器提供的运算符进行重载，以实现特殊的含义。运算符重载需要使用operator关键字，其后是需要重载的运算符，参数及返回值，根据实际需要来设置。e.g.1 实现运算符“+”重载函数。 123456789101112131415161718192021222324class CBook&#123;public: int m_Pages; void OutputPages() &#123; printf("%d\n",m_Pages); &#125; CBook operator+(CBook &amp;book) // 实现两个对象的相加 &#123; CBook bk; bk.m_Pages = this-&gt;m_Pages + book.m_Pages; return bk; &#125;&#125;;int main()&#123; CBook vbBook,vcBook,vfBook; vbBook.m_Pages = 20; vcBook.m_Pages = 30; vfBook = vbBook + vcBook; vfBook.OutputPages(); return 0;&#125; e.g.2 重载运算符“+”，实现对象与整数相加。 12345678910111213141516CBook operator+(int pages)&#123; CBook bk; bk.m_Pages = m_Pages +pages; return bk;&#125;// 调用重载函数int main()&#123; CBook vbBook,vcBook; vbBook.m_Pages = 20; vcBook = vbBook + 10; // 这里不可以交换参数的顺序； vcBook = 10 + vbBook; // 非法 return 0;&#125; 慎用this指针// 使用this指针实现运算符重载CBook operator+(int pages){ this-&gt;m_Pages = m_Pages + pages; return *this;}这种方法是错误的，虽然可以实现相加，但是使用this指针直接修改了对象的数据，会造成错误。 对于单目运算符“++”、“–”，涉及到前置运算和后置运算，在重载这类运算符时需要加以区分；默认情况下，如果重载运算符没有参数，则表示是前置运算。 12345678void operator++() // 前置运算&#123; ++m_Pages;&#125;void operator++(int) // 后置运算,参数的值可以忽略，int在这里只是一个标识，标识该重载为后置运算&#123; ++m_Pages;&#125; e.g.3 重载”++“运算符，并使其可以赋值给一个对象。 12345678910111213CBook operator++() // 前置运算&#123; CBook bk; bk.m_Pages = ++this-&gt;m_Pages; return bk;&#125;CBook operator++(int) // 后置运算&#123; CBook bkl bk.m_Pages = this-&gt;m_Pages++; return bk;&#125; 运算符重载写重载函数时，避免修改对象的原始数据，捋清函数的返回值类型和运算符要用到的参数类型；其次，运算符函数默认传递this指针（即当前对象）作为其参数。 e.g.4 重载赋值“=”运算符,可实现将一个整数赋值给一个对象。 1234void operator=(int pages)&#123; m_Pages = pages;&#125; 也可以重载构造函数将一个整数赋值给一个对象。 1234567891011121314151617class CBook&#123;public: int m_Pages; void OutputPages() &#123; printf("%d\n",m_Pages); &#125; CBook() &#123; ; &#125; CBook(int pages) &#123; m_Pages = pages; &#125;&#125;; 无论是重载运算符还是重载构造函数都无法实现反向赋值，即将一个对象赋值给一个整型变量。但转换运算符可以！转换运算符由关键字operator开始，其后是转换为的数据类型。 123456789101112operator int() // operator关键字前没有数据类型，即不能指定返回值类型&#123; return m_Pages;&#125;int main()&#123; CBook vbBook(300); int pages; pages = vbBook; // 将CBook对象赋值给整型数据 printf("%d\n",pages); return 0;&#125; 1.8 友元类和友元方法当用户希望另一个类能够访问当前类的私有成员时，可以在当前类中将另一个类作为自己的友元类，这样在另一个类中就可以访问当前类的私有成员了。 直接将另一个类声明为当前类的友元类。123456789101112131415161718192021222324252627282930313233343536class CItem&#123;private: char m_Name[128]; void OutputName() &#123; printf("%s\n",m_Name); &#125;public: friend class CList; // 将CList声明为自己的友元类 void SetItemName(const char* pchData) &#123; if(pchData!=NULL) &#123; strcpy(m_Name,pchData); // 赋值字符串 &#125; &#125; CItem() &#123; memset(m_Name,0,128); // 初始化数据成员 &#125;&#125;;class CList&#123;private: CItem m_Item;public: void OutputItem();&#125;;void CList::OutputItem()&#123; m_Item.SetItemName("Beijing"); m_Item.OutputName();&#125; 在CItem中将CList声明为了其友元类，所以CList可以访问CItem中的所有私有成员。 定义友元函数实现只允许CList类的某个成员访问CItem类的私有成员，限制只有该方法允许访问CItem类的私有成员。 12345678910111213141516171819202122232425262728293031323334353637class CItem; // 前导声明CItem类class CList&#123;private: CItem *m_pItem;public: CList(); ~CList(); void OutputItem(); &#125;;class CItem&#123;friend void CList::OutputItem();private: char m_Name[128]; void OutputName() &#123; printf("%s\n",m_Name); &#125;public: void SetItemName(const char* pchData) &#123; if(pchData!=NULL) &#123; strcpy(m_Name,pchData); &#125; &#125; CItem() &#123; memset(m_Name,0,128); &#125;&#125;void CList::OutputItem()&#123; m_pItem -&gt; SetItemName("Beijing"); m_pItem -&gt; OutputNanme(); // 在友元函数中访问私有方法&#125; 友元函数不仅可以是类内函数，也可以是一个全局函数。只需要在类中声明全局函数为友元函数，全局函数即可访问该类的私有成员。 1.9 类的继承继承是面向对象的主要特征之一（另外两个是封装和多态）；继承使得一个类可以从现有类中派生，不必重新定义一个新的类；继承类称为子类，被继承类称为父类（基类）。 1234class COperator:public CEmployee&#123;&#125;; 运算符“:”表示当前类派生与一个基类，public关键字表示派生类为公有型。共有3种派生类型：公有型（public),私有型（private）,保护型(protected)。public型表示对于基类中的public数据成员和方法，在派生类中仍是public型；private型表示对于基类中的public数据成员和方法，在派生类中均为private型;protected型表示对于基类中的public数据成员和方法，在派生类中均为protected型。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++面向过程程序设计]]></title>
    <url>%2F2019%2F09%2F04%2FCpp4%2F</url>
    <content type="text"><![CDATA[定义和使用函数 设计递归函数 理解命名空间的使用 定义函数模板 一、函数1.1 定义函数 函数的定义返回值类型 函数名 （参数列表）{ 函数体;} 在定义函数参数时，如果多个参数具有相同的数据类型，则需要分别定义，不允许整体定义。 1234int sum(int x,y) //语法错误，不允许整体定义&#123; ; // 可以先将函数设置为空函数，之后需要进行功能补充时再完善函数体&#125; 在调用函数时，如果当前函数处于被调用函数的下方，则需要对被调用函数进行前置声明。 1234567891011int sum(int i,int j);int main(int argc,char* argv[])&#123; int ret=0; ret = sum(m,n); return 0;&#125;int sum(int i,int j)&#123; return i+j;&#125; argc 与argv[]的作用定义主函数 int main(int argc,char* argv[])其中，argc为整型，用来统计程序运行时发送给main函数的命令行参数的个数。在VS中默认为1；char* 型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组（即存放参数的地址），每一个元素指向一个参数。 1.2 设置默认值参数在调用有参函数时，如果经常需要传递同一个值到调用函数，可以在定义函数时为参数设置一个默认值，这样在调用函数时便可以省略一些参数。在定义函数默认值参数时，如果函数有多个参数，应保证默认值参数在参数列表的右方。 12345678910111213141516void OutputInfo(const char* pchData = "One world,one dream!");&#123; printf("%s\n",pchData); &#125;## 1.3 设置数组参数使用数组作为参数时，可以不指定数组的长度。在调用数组参数的函数时，C++编译器不对数组的长度进行检查，只是传递数组首地址。```Cvoid Sorted(int arr[10])&#123; ;&#125;// 可以不指定数组的长度，使用一个单独的参数len传递数组的长度，这样更加灵活void Sorted(int arr[]],int len)&#123; ;&#125; 如何通过数组参数来限制函数调用时必须传递指定长度的数组？解决方法：使用数组的引用作为函数的参数。e.g 使用数组的引用作为函数参数。 12345678910111213141516171819202122void Sorted(int (&amp;array)[10])&#123; int t = 0; int i,j; for(i=0;i&lt;10-1;i++) &#123; for(j=0;j&lt;10-1-i;j++) &#123; if(array[j]&lt;array[j+1]) &#123; t = array[j]; array[j] = array[j+1]; array[j+1] = t; &#125; &#125; &#125; cout &lt;&lt; "排序后的结果：" &lt;&lt;endl; for(i=0;i&lt;10;i++) printf("%2d",array[i]); cout &lt;&lt; endl;&#125;// 调用此函数，参数必须时长度为10的整型数组。 数组引用int (&amp;array)[10]; //定义一个引用array,取代长度为10的数组int (*array)[5]; //定义一个整型指针，指向长度为5的数组int &amp;array[10]; //非法，不可以定义引用数组int *array[5]; //定义一个指针数组 1.4 设置指针/引用参数 函数参数的传递方式值传递：在函数调用时，将实际参数的值复制一份传递到调用函数中。如果在调用函数中修改了参数的值，不会影响实际参数的值。引用传递：在调用函数中修改了参数的值会影响实际参数的值。若参数为指针、引用、数组类型，则为引用传递，否则为值传递。 使用引用、指针参数的区别？对于引用参数，引用必须被初始化为一个对象，并且不能使它再指向其他对象，因为对引用赋值实际上是对目标对象赋值。在函数中，无法验证引用参数的合法性。对于指针参数，用户可以随意修改指针参数指向的对象，但需要验证数组是否为空。（不太明白……)引用指向其他对象？如何验证指针参数是否为空？if (parry==NULL){ cout &lt;&lt; “指针为空“ &lt;&lt; endl;} 1.5 省略号参数省略号参数代表的含义是：函数的参数是不固定的，可以传递一个或多个参数。定义省略号参数函数，在编写函数体时需要一一读取用户传递的实际参数。可以使用va_list类型和va_start,va_arg,va_end 3个宏读取传递到函数中的参数值。 123456789101112131415161718void OutputInfo(int num,...) // 定义一个省略号参数函数&#123; va_list arguments; //定义 va_list类型变量 va_start(arguments,num); while(num--) // 读取所有参数的数据 &#123; char* pchData = va_arg(arguments,char*); // 获取字符串数据 int iData = va_arg(arguments,int); printf("%s\n",pchData); printf("%d\n",iData); &#125; va_end(arguments);&#125;int main(int argc, char* argv[])&#123; OutputInfo(2,"Beijing",2008,"Olympic Games",2008); return 0;&#125; 1.6 内联函数 对程序中出现函数调用的地方，如果函数是内联函数，则编译器直接将函数代码赋值到函数调用的地方，这样便省去了跳转到函数定义的地方执行代码然后再返回到调用函数处的一个过程，提高了代码执行的效率。 内联函数一个缺点是增加了代码量。对于短小的、经常使用的函数可以将其定义为内联函数。使用inline 关键字定义内联函数。123inline void testDemo()&#123; ;&#125; inline只是对编译器的一个建议，编译器是否将其作为内联函数处理依赖于编译器的优化机制。 1.7 链接指示符 extern “C”extern “C” 表示函数是使用其他语言写的。由于不同厂家、不同语言的编译器对函数的默认调用约定不同，导致不同语言对函数的参数处理顺序不同，所以为了能在C++中调用其他语言写的函数，需要用到链接指示符。extern “C” 通过3种方式标识函数： 只标识一个函数 1extern "C" bool Validate(float x) 使用复合语句标识一组函数 12345extern "C"&#123; bool Validate(float x); void OutputInfo(const char* cData);&#125; 通过引用头文件标识头文件中的所有函数 1234extern "C"&#123; #include "inlinedemo.h"&#125; 1.8 重载函数重载函数指多个函数具有相同的函数名称，而参数类型或参数个数不同。函数调用时，编译器以参数的类型及个数来区分调用哪一个函数。定义重载函数需要注意： 函数的返回值类型不作为区分重载函数的一部分 对于普通的函数参数，const关键字不作为区分重载函数的标识，但是若参数为指针或引用类型，则const关键字可作为重载函数的标识 参数的默认值不作为区分重载函数的标识 typedef自定义类型不作为重载的标识 123456789typedef int INT;bool Validate(INT x)&#123; return (x&gt;10)?true:false;&#125; bool Validate(int x) // 不合法重载&#123; return (x&gt;10)?true:false;&#125; 局部域中声明的函数将隐藏而不是重载全局域中的函数 12345678910111213141516171819bool Validate(int x) &#123; return (x&gt;10)?true:false;&#125;bool Validate(float x) &#123; return (x&gt;10)?true:false;&#125;int main(int argc,char* argv[])&#123; bool Validate(double x,double y); // 在局部域中声明函数 Validate(1.5f); // 报错，第二个函数被隐藏 // ::Validate(1.5f); // 使用作用域运算符::访问被隐藏的全局函数 return 0;&#125;bool Validate(double x,double y) &#123; return (x&gt;y)?true:false;&#125; 1.9 函数递归调用函数递归是指函数直接或间接调用其本身。递归直接调用是指在函数体中再次调用该函数，递归间接调用是指函数调用另一个函数，而被调用的函数又调用了第一个函数。e.g 利用递归求n的阶乘。 12345678typedef unsigned int UINT;int factorial(const UINT n)&#123; if(n ==0 || n==1) return 1; else return n*factorial(n-1);&#125; 递归函数必须有终止条件！递归函数会增加系统的额外开销，导致程序性能下降，如果传递一个很大的数，会导致堆栈溢出，因为每调用一次函数，系统便会为函数的参数分配堆栈空间。 1.10 函数指针函数名实际上是指向函数的长指针。使用typedef定义一个函数指针类型，然后定义该类型的变量。函数指针必须与函数的 返回值类型、参数个数、参数类型保持一致。 12345678typedef int (*ptfun)(int,int); // 定义一个指向具有两个整型变量的函数的指针ptfun fun; // 使用指针类型定义一个变量int sum(int x,int y)&#123; return x+y;&#125;fun = sum;int ret = fun(2,5); 使用函数指针可以增加程序的灵活性。 12345678910111213141516171819202122232425262728293031int Invoke(int x,int y,pfun fun)&#123; return fun(x,y);&#125;// 函数具有统一的形式，相同的返回值类型，参数个数和参数类型，只是对数据的处理方式不同。int sum(int x,int y)&#123; return x+y;&#125;int sub(int x,int y)&#123; return x-y;&#125;int mul(int x,int y)&#123; return x*y;&#125;int div(int x,int y)&#123; return x/y;&#125;int main()&#123; pfun fun; int ret = 0; fun = sum; // 只需要改变fun指向的函数即可。 ret = Invoke(20,10,fun); fun = div; ret = Invoke(20,10,fun); return 0;&#125; 定义函数指针数组1234567891011121314151617181920212223242526int (*pfun[4])(int,int);pfun[0] = sum;pfun[1] = sub;pfun[2] = div;pfun[3] = mul;for(int i=0;i&lt;4;i++)&#123; int ret = pfun[i](20,10); printf("%d\n",ret);&#125;# 二、作用域和生命期作用域和生命期描述了常量、变量、函数等对象的适用范围。## 2.1 局部作用域1. 描述了函数体或复合语句中变量、常量等对象的作用范围；1. 对于处于同一局部作用域的对象，是不允许重名的；1. 当编译器在当前代码处发现变量名时，它将在当前的局部作用域中搜索变量的定义，若未发现变量的定义，则向外一层继续搜索，直至搜索完全局作用域。如果仍未发现变量的定义，则会出现标识符没有定义的错误。1. 如果在嵌套局部作用域的外层和内部作用域定义了同名的变量，内部的局部作用域的变量会将外部变量隐藏。```Cint ivar = 5;int main(int argc,char* argv[])&#123; printf("ivar = %d\n",ivar); char *ivar = "Hello World!"; printf("%s\n",ivar);&#125; str[] 与 *str 的区别所有以“” 或‘’包含的字符、字符串都是常量，是存储在堆上的。char str[] = “hello” 定义了一个局部字符数组，是一个局部变量，不能在函数中返回其数组地址，函数结束时数组地址是一个已经释放了的空间地址。str在栈上申请空间，将常量内容复制进来，所以是局部变量。char *str = “hello” 表示先定义一个字符串常量，并将其地址赋给str。str存储在全局静态存储区。 2.2 全局作用域全局作用域的作用范围是整个应用程序。全局对象、全局函数、全局变量…… 全局作用域定义的变量如果没有被初始化，默认为0；局部变量则不确定； 整个应用程序中，全局变量只能被定义一次，不能重名； 如果一个函数中定义的局部变量与全局变量重名，则全局变量被隐藏，需要使用运算符::对全局变量进行访问。12345678&#123; int ivar = 5; &#123; int ivar = 10; printf("局部ivar = %d\n",ivar); //输出局部变量 printf("全局ivar = %d\n",::ivar); //访问全局变量 &#125;&#125; 2.3 定义和使用命名空间在一个应用程序的多个文件中，可能存在同名的全局对象，会导致程序链接错误。可以使用命名空间消除命名冲突。 命名空间的定义格式：1234namespace 名称&#123; 常量、变量、函数等对象的定义;&#125; e.g 定义两个命名空间。 1234567891011121314151617181920212223namesapce Output // 定义一个命名空间 Output&#123; const int MAXLEN = 128; int ivar = 10; void PutoutText(const char* pchData) &#123; if(pchData != NULL) &#123; printf("PutoutText命名空间：%s\n)",pchData); &#125; &#125;&#125;namespace Windows // 定义一个命名空间 Windows&#123; typedef unsigned int UINT; void PutoutText(const char* pchData) &#123; if(pchData != NULL) &#123; printf("Windows 命名空间:%s\n",pchData); &#125; &#125;&#125; 使用命名空间1Output::PutoutText("Hello World!"); 需要访问命名空间中的多个对象，也可以使用using命令引用整个命名空间对象。 12using namespace Output; // 引用 Output 命名空间PutoutText("Hello World!"); // 访问 Output 命名空间中的函数 using命令的作用域从当前引用处到当前作用域的结束。如果将using命令放置在复合语句中，则复合语句结束时，using的作用域也随之结束了。 在函数中定义的局部变量与命名空间中的变量同名时，命名空间中的变量将被隐藏。 12345678int main(int argc,char* argv[])&#123; int ivar = 5; // 定义局部变量 using namesapce Output; // 引用命名空间 PutoutText("hello world!"); printf("%d\n",ivar); // ivar的值为5，函数内部定义的局部变量将命名空间中的变量隐藏了 printf("%d\n",Output::ivar); // ivar 的值为10&#125; 如果程序中使用using命令引用了多个命名空间，且命名空间中存在相同的函数，将导致歧义。解决方法是使用作用域运算符::区分。 12345678int main()&#123; using namespace Output; using namesapce Windows; Output::PutoutText("Hello,"); Windows::PutoutText("World!"); return 0;&#125; 对于同一个命名空间，可以在多个文件中定义。命名空间中的内容为两个文件命名空间内容的总和。 在定义头文件时，通常在头文件中声明命名空间中的函数，在源文件中定义命名空间中的函数。 1234567891011// 在头文件中声明命名空间中的函数namespace Output&#123; void Demo(); &#125;// 在源文件中定义命名空间中的函数// 使用命名空间作为前缀，表明实现的是命名空间中的函数，否则定义的是全局函数。Output::Demo()&#123; printf("This is a function.\n");&#125; 可以定义嵌套的命名空间。 1234567891011121314151617181920212223242526272829namespace Output&#123; typedef unsigned int UINT; int ivar = 10; void OutputText(const char* data) &#123; if (data!=NULL) &#123; printf("Output命名空间:%s\n",data); &#125; &#125; namespace GDI &#123; int ivar = 5; void WriteText(const char* pchMg) &#123; printf("GDI命名空间：%s\n",pchMg); &#125; &#125;&#125;// 访问GDI空间中的函数/对象Output::GDI::WriteText("Welcome!");// 或 使用using语句访问using namespace Output::GDI;WriteText("Welcome!");// 只是引用了GDI空间，并没有引用Output空间OutputText("hello!"); //非法Output::OutputText("hello!); // 合法 命名空间可以不命名。未命名的命名空间中的对象只适用于当前文件，各个文件之间不能相互访问定义在各自未命名空间中的对象，所以在未命名空间中的对象相当于静态（satic)全局变量（静态全局变量相当于半个全局变量，他只能在当前文件使用）。在定义未命名空间中的对象时，注意其中的对象不能与全局对象同名或相同，（函数可以重名，表示函数重载，但参数列表不能相同）。 三、函数模板3.1 定义函数模板C++使用template定义模板。 12345template &lt;class type&gt; // 定义一个模板类型type Sum(type xvar,type yvar)&#123; return xvar+yvar;&#125; 定义函数模板&lt;&gt;表示模板参数，模板参数分为两种，一种是模板类型参数，使用关键字class或typedef定义，另一种为模板非类型参数，与普通变量定义相同。template 关键字定义一个模板，可以是函数模板也可以是类模板。 3.2 使用函数模板12345678int ret = Sum(10,20);double ret = Sum(10.2,20.1);// 如果为函数传递两个类型不同的参数，编译器会产生歧义int ret = Sum(10.5,20); // 错误调用double ret = Sum(10,20.5);// 若用户在调用时显示地标识出模板的参数类型，则不会产生歧义int ret = Sum&lt;int&gt;(10.5,20);double ret = Sum&lt;double&gt;(10,20.5); e.g 定义一个函数模板，使用模板类型参数和模板非类型参数，求数组的最大值。 12345678910111213141516171819template &lt;typedef type,int len&gt;type Max(type array[len])&#123; type ret = array[0]; for(int i=0;i&lt;len;i++) &#123; if (array[i]&gt;ret) &#123; ret = array[i]; &#125; // ret = (ret&gt;array[i])?ret:array[i]; &#125; return ret;&#125;// 调用函数模板int arr[5] = &#123;1,2,3,4,5&#125;;int Max&lt;int,5&gt;(arr);double array[3] = &#123;1.1,2.2,3.3&#125;;double Max&lt;double,3&gt;(array); 3.3 重载函数模板函数模板重载与函数重载相同，区分点在于参数类型和参数类型不同。 1234567891011121314151617181920212223242526272829// 定义重载函数模板template &lt;class type&gt;type Sum(type xvar,type yvar)&#123; return xvar+yvar;&#125;template &lt;class type&gt;type Sum(type array,int len)&#123; type sum = 0; for(int i=0;i&lt;len;i++) &#123; sum+=array[i]; &#125; return sum;&#125;// 调用重载函数模板int main(int argc,char* argv[])&#123; int x=5, y=10; int array[5] = &#123;1,2,3,4,5&#125;; int sum = 0; sum = Sum(x,y); printf("两数之和为:%d\n",sum); sum = Sum(array,5); printf("数组各元素之和为:%d\n",sum); return 0;&#125; 函数参数为数组如果函数的参数为数组，一般的定义形式为：int sumDemo(int array[],int len){;}这里测试了一下，对于函数模板，以下两种形式均可：第一种：template &lt;class type,int len&gt; // 这里指出模板非类型参数lentype testSum(type array[len]){;}调用格式：int array[5] = {1,2,3,4,5};sum = testSum&lt;int,5&gt;(array); // 调用时显式地标识出模板的参数类型第二种：template // 这里不需要指定模板非类型参数type testSum(type array[],int len){;} // 函数定义时在参数类表中指出模板非类型参数，与普通函数一样调用格式：sum = testSum(array,5); // 调用时可以指出模板的参数类型，直接带入参数即可。 四、练习4.1 编写一个函数，使用指针作为参数，实现两个数的互换。1234567891011121314151617#include &lt;iostream&gt;using namespace std;void swarpDemo(int* x,int* y)&#123; int t = 0; t = *x; *x = *y; *y = t;&#125;int main(int argc, char* argv[])&#123; int i = 3, j =4; swarpDemo(&amp;i,&amp;j); cout &lt;&lt; "i = " &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; "j = " &lt;&lt; j &lt;&lt; endl; return 0 ;&#125; 4.2 编写一个函数模板，实现对各种数据类型数组进行从小到大的排序。123456789101112131415161718192021222324252627282930313233343536# include &lt;iostream&gt;using namespace std;template &lt;class type&gt;void sortArrayDemo(type a[],int len)&#123; type t; int i,j; for(i=0;i&lt;len-1;i++) &#123; for(j=0;j&lt;len-1-i;j++) &#123; if(a[j]&gt;a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125;&#125;int main(int argc,char* argv[])&#123; int a[5] = &#123;5,4,3,2,1&#125;; double b[6] = &#123;0.2,3.2,4.0,9.6,2.3,4.5&#125;; sortArrayDemo(a,5); sortArrayDemo(b,6); int i; cout &lt;&lt; "a排序后："&lt;&lt; endl; for(i=0;i&lt;5;i++) cout &lt;&lt; a[i] &lt;&lt; endl; cout &lt;&lt; "b排序后：" &lt;&lt; endl; for(i=0;i&lt;6;i++) cout &lt;&lt; b[i]&lt;&lt; endl; return 0 ;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 数据类型]]></title>
    <url>%2F2019%2F08%2F29%2FC-language-foundation%2F</url>
    <content type="text"><![CDATA[变量的存储类型 extern static register auto 数据类型 数组类型 枚举类型 布尔类型 结构体类型 指针类型 自定义类型 引用类型 运算符 左移&lt;&lt; 右移&gt;&gt; sizeof new delete 练习 冒泡法 Fibonacci数列 一、变量的存储类型变量通常有4种存储类型，分别为extern,static, register, auto。 extern 变量的定义与声明之间的区别&emsp;变量的定义：将为变量分配存储空间；&emsp;变量的声明：告知编译器变量的名称和数据类型 为什么只声明不定义？如果在一个文件中定义一个全局变量，可能需要在其他文件进行访问，在其他文件使用extern可以只声明而不定义全局变量，这样即可共享全局变量。e.g. 在一个文件中定义全局变量var 1int var = 0; 在另一个文件中通过使用extern关键字声明全局变量即可访问变量var。 1extern int var; static 静态变量：分为全局静态变量和局部静态变量。 在函数内部定义一个局部静态变量，则在函数执行后变量的值会保留。 12345void TestStaticVar()&#123; static int var=1; printf("var=%d\n",var++);&#125; 全局静态变量的作用域仅限于当前定义的文件，不能被其他文件使用extern关键字进行访问。 register 表示变量将被放置在CPU的寄存器中，访问寄存器变量要比访问普通变量快得多； register变量只能用于局部变量或作为函数的形式参数，不能用于定义全局变量。 1register int var = 0; auto 静态存储与动态存储&emsp;变量的存储方式分为两种——静态存储和动态存储&emsp;全局变量、静态变量均属于静态存储；&emsp;局部变量属于动态存储。 关键字auto表示变量将被动态存储，默认局部变量均为动态存储，且定义一个全局变量为动态存储是非法的。 二、数据类型2.1 数组类型一维数组数组的定义格式：数组数据类型 数组名称[数组长度]; 1int array[10]; 对数组进行初始化： 可以全部赋值，全部赋值可以省略数组长度 12int array[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int array[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; 可以部分赋值 1int array[10] = &#123;1,2,3,4,5&#125;; 可以将其全部初始化为0 1int array[10] = &#123;0&#125;; 二维数组 数组的定义格式：数组数据类型 数组名称[行][列] 1int array2D[3][4]; 数组的初始化： 123int array2D[3][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int array2D[3][4] = &#123;&#123;1,2,3,4&#125;&#125;int array2D[ ][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; //可以省略第一位的长度但不能省略第二维的长度。 2.2 枚举类型 使用enum关键字定义枚举类型 提供一组常量的组合 定义时可以为常量提供数值，若没有提供，则默认第一个常量为0，第二个常量为1；若提供数值，则默认常量对应的数值是前一个常量的数值+112345678910111213141516171819202122232425262728293031323334enum InstanceState(CLOSE=1, OPEN, MOUNT=4,UNMOUNT);void OracleOpt(InstanceState state)&#123; switch (state) &#123; case CLOSE: &#123; printf("关闭数据库!\n"); break; &#125; case OPEN: &#123; printf("打开数据库。\n"); break; &#125; case MOUNT: &#123; printf("挂起数据库。\n"); break; &#125; case UNMOUNT: &#123; printf("卸载数据库。\n"); break; &#125; default: break; &#125;&#125;void main()&#123; InstanceState state; OracleOpt(state);&#125; 2.3 布尔类型 布尔类型只有两种取值：true false 布尔类型可以赋值给整型，true 表示1 ，false表示0 整型也可赋值给bool类型，非0为true，0为false 2.4 结构体类型 结构体是一组不同类型的变量的集合，使用关键字struct声明一个结构体类型 12345678const int MAX_CHAR = 128;struct Student&#123; char name[MAX_CHAR]; char sex[MAX_CHAR]; unsigned int age; char addr[MAX_CHAR];&#125;; //定义最后一定记得加; 定义结构体变量 12struct Student stdnt;Student stdnt; 直接在定义结构体类型时给出定义的变量 1234567struct Student // 若变量只需定义一次，结构体名称Student可以省略&#123; char name[MAX_CHAR]; char sex[MAX_CHAR]; unsigned int age; char addr[MAX_CHAR];&#125;stdnt; 2.5 指针类型 定义指针 数据类型 指针变量名1234int *pi; // 定义整型指针变量int ivar = 10; // 定义整型变量pi = &amp;ivar; // 取ivar的地址赋给pi// int *pi = &amp;ivar; 取值* 取地址&amp;int var =10;int *pi;pi=&var;*pi=8; // 可以修改变量的值 定义指针数组1int *parray[5]; 指针数组中的每一个值都是指针。 使用const关键字定义指针12345678// 不能修改指针指向的变量的值，但可以修改指针指向的地址const int *pvar=&amp;var;// 不能修改指针指向的地址，但可以修改指针指向的数据int const *pvar=&amp;var;// 既不能修改指针指向的地址，也不能修改指针指向的数据const int const *pvar=&amp;var; 2.6 自定义类型使用关键字typedef自定义数据类型，为已存在的数据类型定义一个新的名称 12// typedef 数据类型 新的名称;typedef unsigned int UINT; 2.7 引用类型引用可认为是“别名”，即目标的代名词。当定义一个引用时，需要为其指定一个对象，即目标。此时，操作引用与操作实际的目标对象时相同的。定义引用的格式： 1数据类型 &amp;引用名称 = 目标对象; e.g 使用引用对象代替目标对象。 12345678void main()&#123; int ivar = 10; int &amp;rvar = ivar; rvar = 5; printf("ivar = %d\n",ivar); printf("rvar = %d\n",rvar);&#125; 引用变量引用变量rvar即目标变量ivar的代名词，对rvar取地址其实就是对ivar取地址。 三、运算符3.1 左移运算符 &lt;&lt;1int iret =10 &lt;&lt;2; 3.2 右移运算符 &gt;&gt;1int iret=10 &gt;&gt;2; 3.3 sizeof运算符用于返回变量所占的字节数 用于返回变量、对象或数据类型的字节长度 123int ivar=10;int size=sizeof(ivar); // 获取变量ivar的大小int typesize=sizeof(int); //获取int类型的大小 用于确定数组的大小 1234int iarray[5] = &#123;1,2,3,4,5&#125;;int arraysize = sizeof(iarray); // 获取整型数组的大小，为20char carray[] ="Hello";int carray=sizeof(carray);// 为6，字符串常量系统自动加"\0"作为结束标记 用于确定指针的大小对于32位的操作系统，无论指针指向是何种类型或指向何种类型的数据，指针的长度均为4，因为指针是按32位来寻址的，长度位4 byte。对于64位的操作系统，则指针长度位8. 3.4 new 和 delete运算符 数据存储方式：堆存储、栈存储&emsp;堆存储：通常同于存储占用空间大、生命周期长的数据，e.g.静态变量和全局变量等。&emsp;栈存储：通常用于存储占用空间小、生命周期短的数据，e.g.局部变量和函数参数等。 除了全局变量和静态变量，用户可以使用关键字new开辟堆存储。 1234int *pvar = new int; //定义一个整型指针，调用new在堆中为其分配内存*pvar = 10; //设置指针的值printf("pvar= %d\n",*pvar); //输出指针的值delete pvar; //释放指针指向的堆空间 使用new分配堆空间时，对其进行初始化 1int *pvar = new int(10); //pvar指向的数据位10 使用new为数组动态分配存储空间 1int *pvar = new int[10]; //定义一个整型指针，调用new在堆中分配数组空间，将首地址赋值为指针pvar。 使用new运算符为数组分配空间时，不能对数组进行初始化（除非变量是一个对象，并且对象的类提供了默认的构造函数）。在释放new为数组分配的空间时，需要使用delete[]来释放。 12int *pvar = new int[5];delete [] pvar; 四、练习4.1 不使用库函数，复制源字符串到目标字符串，实现strcpy()的功能。12345string copyStr(string a)&#123; string b = a; return b;&#125; 4.2 接收一个字符串作为输入参数，将其逆序输出123456789void reverseStr(string a)&#123; int len = a.length(); for(;len&gt;=0;len--) &#123; cout &lt;&lt; a[len]; &#125; cout &lt;&lt; endl;&#125; 求字符串的长度&emsp; str.length() str.size() 均可直接得到字符串的长度&emsp; 若将字符串保存在char数组中，则最后一位系统默认位’\0’&emsp; 函数strlen()，求字符串的长度 4.3 使用冒泡法对数组进行排序1234567891011121314151617181920void Bubbling(int a[],int len)&#123; int i,j,t = 0; for(i,i&lt;len-1;i++) &#123; for(j;j&lt;len-1-i;j++) &#123; //从小到大 if(a[j]&gt;a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = a[j]; &#125; &#125; &#125; for(int k=0;k&lt;len;k++) cout &lt;&lt; a[k]; cout &lt;&lt;endl;&#125; 求数组的长度数组的长度：sizeof(数组地址)/sizeof（数组数据类型）但是这里有一个点没搞明白，为什么不可以在函数内求数组的长度呢，而要将数组的长度当作一个参数？？测试了一下在函数内求数组的长度，求的结果是不对的…. 排序算法：冒泡法如果数组的长度是len,则我们需要排（len-1)趟，第i趟排（len-1-i)次。 4.4 使用数组输出Fibonacci数列（又称，斐波那契数列、黄金分割数列、兔子数列）。Fibonacci数列的特点：F(1)=1,F(2)=1,F(n)=F(n-1)+F(n-2)(n&gt;=3,n∊N*) 12345678910111213141516void printFibonacci()&#123; int i; int f[20]=&#123;1,1&#125;; for(i=2;i&lt;20;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; for(i=0;i&lt;20;i++) &#123; if(i%5==0) printf("\n"); printf("%8d",f[i]); &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语句]]></title>
    <url>%2F2019%2F08%2F29%2FCppStatement%2F</url>
    <content type="text"><![CDATA[C++ 语句构成 使用分支语句设计逻辑条件判断 掌握各种循环语句在程序开发中的应用 应用跳转语句改变代码的执行顺序 一、复合语句 注意复合语句中变量的定义域在复合语句中定义的变量，其作用域范围在当前定义变量处到复合语句结束。 123456789int ivar = 1;&#123; int ivar = 1; &#123; ivar = 2; printf("ivar = %d\n",ivar); //ivar = 2 &#125;&#125;printf("ivar = %d\n",ivar); //ivar = 1 二、分支语句if 语句if 语句格式 123456if(表达式) 语句;else if(表达式) 语句;else 语句; switch语句switch 语句格式 123456789switch(表达式/变量名)&#123; case 常量1: break; case 常量2: break; default: break;&#125; 1234567891011121314151617int main()&#123; enum State &#123;CLOSE,OPEN&#125;; State s =CLOSE; switch(s) &#123; case CLOSE: printf("Close!\n"); break; case OPEN: printf("Open!\n"); break; default: break; &#125; return 0;&#125; 注意⚠️这里记住 枚举型如何定义？没有=，没有‘’switch 语句用{}如果switch语句中没有break;当表达式与常量相匹配时，将执行当前case语句代码并继续向下执行case语句代码直到遇到break语句或switch语句结束。case 语句块千万不要忘记加break语句 break 与continue 语句的区别和用法&emsp;break 语句用于跳出循环；&emsp;continue 语句用于结束本轮循环。 三、循环语句for( ; ; )while(){ }do{} while; (分号;不要忘记）四、跳转语句4.1 goto语句goto语句是无条件跳转语句，用于改变代码执行的顺序。使用goto语句时，CPU需要不停地跳转，效率比较低，在开发时应慎用goto语句。 12345678910int main()&#123; int i, sum = 0; label: i++; sum += i; if(i&lt;100) goto label; printf("sum = %d\n",sum);&#125; 在使用goto语句时应注意label的使用，其后不能紧跟 } . 123456int ivar = 0;&#123; //其他操作 label:; //label之后不能紧跟&#125; &#125; 在使用goto语句时应注意goto语句不能越过复合语句之外的变量定义的语句。 1234567891011goto lable_1;int i =0; //不合法，goto语句不能越过label_1: printf("goto\n");goto label_2&#123; int i = 0; //合法&#125;label_2: printf("goto\n"); 4.2 return 语句return 语句用于跳出退出当前函数，当程序在当前函数中执行时，return语句将推出当前函数的执行，返回到函数调用处，继续执行；若当前函数为主函数，则退出应用程序。 12345678910bool ValidateData( const int price)&#123; if (price&gt;1000||price&lt;10) &#123; printf("价格错误！\n"); return false; &#125; printf("验证通过。\n"); return true;&#125; 使用return语句提前结束函数时，需要注意代码之前在堆中分配了内存，在return 语句之前应释放内存，防止内存泄漏。 123456789101112131415161718void ReturnDemo(int min)&#123; int* parr = new int[5]; for(int i=0;i&lt;5;i++) &#123; parr[i] = i; &#125; if(parr[0]&gt;min) &#123; delete[] parr; return; &#125; else &#123; parr[0] = min; &#125; delete[] parr;&#125; 4.3 exit语句exit()是一个用于退出当前调用进程的函数，包含一个整型参数，标识进程退出代码。 1234567void ExitDemo(const int res)&#123; if(res == 0) exit(res); //结束应用程序 else return;&#125; 五、练习5.1 判断是否为素数什么是质数？质数除1和其本身之外没有其他约数。 123456789// 定义法,时间复杂度O(n)bool isPrime_1(int num)&#123; int tmp=num-1; for(int i=2;i&lt;=tmp;i++) if(num%i==0) return 0; return 1;&#125; 一个数若可以进行因数分解，则分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n),所以在判断时不需要遍历至(n-1),遍历至sqrt(n)即可。时间复杂度O(sqrt(n))。 123456789101112131415161718192021222324252627282930#include &lt;math.h&gt;bool isPrime_2(int num)&#123; int tmp = sqrt(num); for(int i=2;i&lt;=tmp;i++) &#123; if(num%i==0) return 0; &#125; return 1;&#125;关于质数的一个规律：大于等于5的质数一定和6的倍数相邻。证明：令x&gt;=1,大于等于5的自然数可以表示为：6i-1,6i,6i+1,6i+2,6i+3,6i+4,6i+5其中，6i一定是6的倍数，6i+2,6i+4一定是2的倍数，6i+3一定是3的倍数，均不是素数，所以只需要考虑6i-1和6i+1，判断其不是5或7，11或13，17或19......的倍数即可。```Cbool isPrime_3(int num)&#123; //先输出小于5的质数 if(num==2 || num==3) return 1; //不在6的倍数两侧的数一定不是质数 if(num%6!=5 &amp;&amp; num%6!=1) return 0; //在6的倍数两侧也不一定是质数 int tmp = sqrt(num); for(int i=5;i&lt;=tmp;i+=6) if(num%i==0 || num%(i+2)==0) return 0; return 1;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战k-近邻算法]]></title>
    <url>%2F2019%2F08%2F25%2FkNN%2F</url>
    <content type="text"><![CDATA[介绍什么是k-近邻算法 每一个函数的作用及包含的Python语法 记录程序调试和运行结果 一、什么是k-近邻算法计算测试样本与训练样本集中每个实例之间的距离，从小到大排序后取前k个实例，通过查看前k个实例的类别百分比确定测试样本的类别。 优点 精度高，对异常值不敏感，无数据输入假定。{%btn #url,缺点,,title%} 计算复杂度高，空间复杂度高适用范围 数值型、标称型 标称型在有限的数据中取值，例如，bool型（包含True和False）、枚举型 二、代码分析2.1 使用Python导入数据123456from numpy import *import operatordef creatDataSet(): group = array([[1,1],[1,1.1],[0,0],[0,0.1]]) labels = ['A','A','B','B'] return group, labels 引入了两个模块，Numpy便于进行数据处理；operator运算符模块。 2.2 kNN算法伪代码对未知类别属性的数据集中的每个点依次执行： 计算已知类别数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点距离最小的k个点； 确定前k个点所在类别的出现频率 返回前k个点出现频率最高的类别作为当前点的预测分类 代码输入：&emsp;&emsp;inX – 用于分类的输入向量&emsp;&emsp;dataSet– 输入训练样本集&emsp;&emsp;labels – 输入训练样本类别&emsp;&emsp;k – 选择的最近邻点数 1234567891011121314151617def classify0(inX, dataSet, labels, k): # 计算距离 dataSetSize = dataSet.shape[0] diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 选择距离最小的k个点 sortedDistIndicies = distances.argsort() # 返回数组值从小到大的索引值 classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #get的用法 get(key,default) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] tile()numpy.tile(A, reps): A 为待输入数组，reps决定了A重复的次数。 sum()axis = 0，按列相加；axis = 1，按行相加 argsort()返回数组值从小到大的索引值 dict.get()dict.get(key,default=None) , 返回指定键的值，若值不存在则返回默认值。 dict.items()返回可遍历的元组数组。undefined sorted()sorted(iterable, cmp=None, key=None, reverse=False)iterable – 可迭代对象cmp – 比较函数key – 用来进行比较的元素，只有一个参数，具体的函数的参数应取自可迭代对象中，指定可迭代对象中的一个元素来进行排序reverse – 指定排序规则，reverse=True 降序， reverse=False 升序（默认） operator.itemgetter()用于获取对象指定维的数据。sorted(iterable, key = operator.itemgetter(1)) 即根据对象的第二维进行排序。 2.3 如何测试分类器错误率：分类器给出错误结果的次数/测试执行的总次数常用来评估分类器在某个数据集上的执行效果。 三、实例：使用k-近邻算法改进约会网站的配对效果3.1 将文本数据转换为Numpy的解析程序返回值：&emsp;returnMat – 特征矩阵&emsp;classLabelVector – 类别向量 1234567891011121314def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() numberOfLines = len(arrayLines) returnMat = zeros((numberOfLines,3)) classLabelVector = [] index = 0 for line in arrayOLines: line = line.strip() listFromLine = line.split('\t') returnMat[index,:] = listFromLine[0:3] classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVector 解读open(filenam):打开指定的文件readlines():按行读取文本strip():删除开头和结尾的空格与换行符str.split(str=””,num= :根据指定的分隔符对字符串进行切片，如果参数num有指定值，则分隔num+1个字符串。&emsp;&emsp; str – 分隔符，默认为所有空字符，包含空格、换行（\n）、制表(\t)&emsp;&emsp; num – 分割次数，默认为-1，即分隔所有。 3.2 分析数据：使用Matplotlib绘制散点图123456import matplotlibimport matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1], datingDataMat[:,2])plt.show() 解读matplotlib.pyplot.scatter(x,y,s,c,marker,cmap)&emsp;x,y – 坐标数据&emsp;s – 数据点的大小&emsp;c – 数据点的颜色&emsp;marker – 数据点的样式&emsp;cmap – 颜色映射 3.3 准备数据：归一化数值归一化公式 normValue = (value - minvalue)/(maxvalue-minvalue) 123456789def autoNorm(dataSet): minValues = dataSet.min(0) maxValues = dataSet.max(0) ranges = maxValues - minValues normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minValues,(m,1)) normDataSet = dataSet/tile(ranges,(m,1)) return normDataSet, ranges, minValues min()&emsp; python是列优先，所以min(0)是按列求最小值；min(1)是按行求最小值 3.4 测试算法123456789101112131415def datingClassTest(): hoRatio = 0.10 datingDataMat,datingLabels = file2matrix('datingTest2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m*hoRatio) errorCount = 0.0 for i in numTestVecs: classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m],\ datingLabels[numTestVecs:m],3) print("the classifier came back with: %d, the real answer is: %d"\ % classifierResult, datingLabels[i]) if classifierResult != datingLabels: errorCount += 1.0 print("the total error rate is : %f" % errorCount/float(numTestVecs)) 解读hoRatio : 测试集所占的比例；normMat[numTestVecs:m]为训练集特征矩阵，datingLabels[numTestVecs]为训练集类别向量 3.5 使用算法：构建完整可用系统1234567891011def classifyPerson(): resultList = ['not at all','in small doses','in large doses'] percentTats = float(input("Percentage of time spent playing video games?")) ffMiles = float(input("Frequent flier miles earned per year?")) iceCream = float(input("Liters of ice cream consumed per year?")) datingDataMat,datingLabels = file2matrix('datingTestSet2.txt') normMat, range, minVals = autoNorm(datingDataMat) inArr = array([ffMiles,percentTats,iceCream]) classifierResult = classify0((inArr-minVals)/range, normMat, datingLabels,3) print("You will probably like this person:",resultList[classifierResult-1]) 四、手写识别系统4.1 准备数据：将图片数据转换为测试向量12345678def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename) for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0,i*32+j] = int(lineStr[j]) return returnVect TypeError: data type not understood该错误发生在zeros()zeros()在创建一维数组时使用一组括号，创建二维数组时需使用两组括号zeros(1024) zeros((1,1024)) zeros(((1,2,1024))) 4.2 测试算法：使用k-近邻法识别手写数字 解读&emsp;hwLabels – 类别向量&emsp;trainingMat – 特征矩阵&emsp; 123456789101112131415161718192021222324252627282930313233def handwritingClassTets():# 获取目录 hwLabels = [] trainingFileList = listdir('digits/trainingDigits') # 获取指定目录下的文件名 m = len(trainingFileList) # 得到文件数量 trainingMat = zeros((m,1024))# 解析数据，得到类别向量和特征矩阵 # trainingMat -- 特征矩阵 m*1024 # hwLabels -- 类别向量 for i in range(m): fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] # 得到文件名 classNumStr = int(fileStr.split('_')[0]) # 得到文件对应的数字即类别 hwLabels.append(classNumStr) trainingMat[i,:] = img2vector('digits/trainingDigits/%s' % fileNameStr)# 解析测试数据，测试每个文件的类别，分析分类结果 testFileList = listdir('digits/testDigits') errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) vectorUnderTest = img2vector('digits/testDigits/%s' %fileNameStr) classifieResult = classify0(vectorUnderTest,trainingMat,hwLabels,3) print("The classifierResult came back with: %d, the real answer is: %d"\ % (classifieResult,classNumStr)) if classifieResult != classNumStr: errorCount += 1.0 print("The total number of errors is :%d" % errorCount) print("The total error rate is: %f" % (errorCount/float(mTest))) 没有归一化这里使用的文件值为0，1，已经在0～1之间，所以不需要归一化处理（autoNorm()). 五、总结 kNN算法是基于实例的学习，使用该算法时必须有接近实际数据的训练样本数据； kNN算法必须保存全部的数据集，如果训练数据集过大，必须使用大量的存储空间； 必须对数据集中的每一个数据进行距离计算，实际使用会很耗时； 无法给出数据的基础结构信息，因此无法知晓平均实例样本和典型实例样本具有什么特征。 六、补充读文件read() readline() readlines() 的区别 read()read(size)：从文件当前位置起读取size个字节，若无参数size，则读取至整个文件结束，返回字符串对象。 readline()readline()：每次读取一行内容，比较适合大文件，输出为字符串对象。f = open(filename,’r’)with open(filename,’r’) as f:for i in range(4): data = f.readline() print(data.strip()) readlines()readlines()：读取整个文件所有行，保存在一个列表（list）变量中，每行作为一个元素，但读取大文件会比较占内存。 linecache模块输出某个文件的第n行import linecachetext = linecache.getline(filename,n)print(text)]]></content>
      <categories>
        <category>Machine-Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode]]></title>
    <url>%2F2019%2F08%2F21%2Fxcode%2F</url>
    <content type="text"><![CDATA[记录使用Xcode过程中遇到的一些坑 一、相对路径问题 配置过程Product —&gt;Scheme —&gt;Edit Scheme —&gt;Options —&gt; Working Directory —&gt;勾选Use custom working directory:并选择工程路径]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pycharm过程中遇到的问题]]></title>
    <url>%2F2019%2F08%2F21%2Fpycharm%2F</url>
    <content type="text"><![CDATA[记录在使用Pycharm时，遇到的一些问题。 一、解决问题1.1 Pycharm 报错 “No module named…”这里提出一个问题，即如何在Pycharm中使用Anaconda部署Python环境 理解几个概念： Python脚本：即.py文件 Python解释器：python.exe ，不同版本的解释器对语法的要求是不同的 Python运行环境：由解释器的版本和第三方库决定 Anaconda的优点： Anaconda可以很方便地管理第三方库，方便管理； 可以创建不同版本的python开发环境，隔离不同的项目要求。 如何在Pycharm中设置Anaconda环境 配置过程打开Pycharm—&gt; Create New Project—&gt; Project Interpreter—&gt; Existing interpreter—&gt; Interpreter—&gt;&gt; …—&gt; Conda Environment —&gt;&gt; users—&gt; anaconda3 —&gt; bin—&gt; python X.X]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法规则]]></title>
    <url>%2F2019%2F08%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 语法说明 一、标题 使用 # 控制 几个 # 代表几级标题 #与文字之间有空格 二、强调1. 加粗在要加粗的字段两侧添加 **这里加粗强调 2. 斜体在要加斜体的字段两侧添加 *这里需要加斜体强调 3. 加粗斜体在字段两侧添加*这里需要 *加粗并斜体*** 4.删除在要删除的字段两侧添加 ~~这句话需要删除~~ 三、列表1、无序列表1234* 项目1* 项目2 * 项目2.1 * 项目2.2 项目1 项目2 项目2.1 项目2.2 2、有序列表1231. 项目11. 项目21. 项目3 项目1 项目2 项目3 项目3.1 项目3.2 四、添加图片 五、链接 可以直接输入网址http://www.baidu.com 可以为网址重命名 1[name](url) 百度 六、引用123俗话说：&gt; 各扫自家门前雪&gt; 休管他人瓦上霜 俗话说： 各扫自家门前雪休管他人瓦上霜 七、分割线1--- 八、行内代码1`&lt;&gt;` 九、代码块9.1 语法高亮添加使用的代码的语言类别 12import numpy as nplist = ['I','Love','U'] 9.2 显示代码行数在语言类别后添加{.line-numbers} &#123;.line-numbers&#125;12import numpy as nplist = ['I','Love','U'] 十、待办事项12- [ ] 阅读文献- [x] 整理笔记 [ ] 阅读文献[x] 整理笔记 十一、表格 First Header Second Header 00 01 10 11 十二、标注 上标12在上标的两侧添加^30^th^ 30^th 下标12在要下标的两侧添加~H_2O H_2O 、CO_3 脚注1[^1] [^1]: Hi, nice to meet you. 高亮1在需要高亮的字符两侧添加== ==marked== Loremdnadkda jdakjd daksdn]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
