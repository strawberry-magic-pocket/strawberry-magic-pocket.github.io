<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++_language_foundation]]></title>
    <url>%2F2019%2F08%2F29%2FC-language-foundation%2F</url>
    <content type="text"><![CDATA[C++ 语言基础 一、变量的存储类型变量通常有4中存储类型，分别为extern,static, register, auto。 **extern** 变量的定义与声明之间的区别&emsp;变量的定义：将为变量分配存储空间；&emsp;变量的声明：告知编译器变量的名称和数据类型 为什么只声明不定义？如果在一个文件中定义一个全局变量，可能需要在其他文件进行访问，在其他文件使用extern可以只声明而不定义全局变量，这样即可共享全局变量。e.g. 在一个文件中定义全局变量var 1int var = 0; 在另一个文件中通过使用extern关键字声明全局变量即可访问变量var。 1extern int var; **static** 静态变量：分为全局静态变量和局部静态变量。 在函数内部定义一个局部静态变量，则在函数执行后变量的值会保留。 12345void TestStaticVar()&#123; static int var=1; printf("var=%d\n",var++);&#125; 全局静态变量的作用域仅限于当前定义的文件，不能被其他文件使用extern关键字进行访问。 **register** 表示变量将被放置在CPU的寄存器中，访问寄存器变量要比访问普通变量快得多； register变量只能用于局部变量或作为函数的形式参数，不能用于定义全局变量。 1register int var = 0; **auto** 静态存储与动态存储&emsp;变量的存储方式分为两种——静态存储和动态存储&emsp;全局变量、静态变量均属于静态存储；&emsp;局部变量属于动态存储。 关键字auto表示变量将被动态存储，默认局部变量均为动态存储，且定义一个全局变量为动态存储是非法的。 二、数据类型2.1 数组类型一维数组数组的定义格式：数组数据类型 数组名称[数组长度]; 1int array[10]; 对数组进行初始化： 可以全部赋值，全部赋值可以省略数组长度 12int array[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int array[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; 可以部分赋值 1int array[10] = &#123;1,2,3,4,5&#125;; 可以将其全部初始化为0 1int array[10] = &#123;0&#125;; 二维数组数组的定义格式：数组数据类型 数组名称[行][列] 1int array2[3][4]; 数组的初始化： 123int array2[3][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int array2[3][4] = &#123;&#123;1,2,3,4&#125;&#125;int array2[][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; //可以省略第一位的长度但不能省略第二维的长度。]]></content>
      <categories>
        <category>Code</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战k-近邻算法]]></title>
    <url>%2F2019%2F08%2F25%2FkNN%2F</url>
    <content type="text"><![CDATA[介绍什么是k-近邻算法 每一个函数的作用及包含的Python语法 记录程序调试和运行结果 一、什么是k-近邻算法计算测试样本与训练样本集中每个实例之间的距离，从小到大排序后取前k个实例，通过查看前k个实例的类别百分比确定测试样本的类别。 优点 精度高，对异常值不敏感，无数据输入假定。{%btn #url,缺点,,title%} 计算复杂度高，空间复杂度高适用范围 数值型、标称型 标称型在有限的数据中取值，例如，bool型（包含True和False）、枚举型 二、代码分析2.1 使用Python导入数据123456from numpy import *import operatordef creatDataSet(): group = array([[1,1],[1,1.1],[0,0],[0,0.1]]) labels = ['A','A','B','B'] return group, labels 引入了两个模块，Numpy便于进行数据处理；operator运算符模块。 2.2 kNN算法伪代码对未知类别属性的数据集中的每个点依次执行： 计算已知类别数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点距离最小的k个点； 确定前k个点所在类别的出现频率 返回前k个点出现频率最高的类别作为当前点的预测分类 代码输入：&emsp;&emsp;inX – 用于分类的输入向量&emsp;&emsp;dataSet– 输入训练样本集&emsp;&emsp;labels – 输入训练样本类别&emsp;&emsp;k – 选择的最近邻点数 1234567891011121314151617def classify0(inX, dataSet, labels, k): # 计算距离 dataSetSize = dataSet.shape[0] diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 选择距离最小的k个点 sortedDistIndicies = distances.argsort() # 返回数组值从小到大的索引值 classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #get的用法 get(key,default) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] tile()numpy.tile(A, reps): A 为待输入数组，reps决定了A重复的次数。 sum()axis = 0，按列相加；axis = 1，按行相加 argsort()返回数组值从小到大的索引值 dict.get()dict.get(key,default=None) , 返回指定键的值，若值不存在则返回默认值。 dict.items()返回可遍历的元组数组。undefined sorted()sorted(iterable, cmp=None, key=None, reverse=False)iterable – 可迭代对象cmp – 比较函数key – 用来进行比较的元素，只有一个参数，具体的函数的参数应取自可迭代对象中，指定可迭代对象中的一个元素来进行排序reverse – 指定排序规则，reverse=True 降序， reverse=False 升序（默认） operator.itemgetter()用于获取对象指定维的数据。sorted(iterable, key = operator.itemgetter(1)) 即根据对象的第二维进行排序。 2.3 如何测试分类器错误率：分类器给出错误结果的次数/测试执行的总次数常用来评估分类器在某个数据集上的执行效果。 三、实例：使用k-近邻算法改进约会网站的配对效果3.1 将文本数据转换为Numpy的解析程序返回值：&emsp;returnMat – 特征矩阵&emsp;classLabelVector – 类别向量 1234567891011121314def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() numberOfLines = len(arrayLines) returnMat = zeros((numberOfLines,3)) classLabelVector = [] index = 0 for line in arrayOLines: line = line.strip() listFromLine = line.split('\t') returnMat[index,:] = listFromLine[0:3] classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVector 解读open(filenam):打开指定的文件readlines():按行读取文本strip():删除开头和结尾的空格与换行符str.split(str=””,num= :根据指定的分隔符对字符串进行切片，如果参数num有指定值，则分隔num+1个字符串。&emsp;&emsp; str – 分隔符，默认为所有空字符，包含空格、换行（\n）、制表(\t)&emsp;&emsp; num – 分割次数，默认为-1，即分隔所有。 3.2 分析数据：使用Matplotlib绘制散点图123456import matplotlibimport matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1], datingDataMat[:,2])plt.show() 解读matplotlib.pyplot.scatter(x,y,s,c,marker,cmap)&emsp;x,y – 坐标数据&emsp;s – 数据点的大小&emsp;c – 数据点的颜色&emsp;marker – 数据点的样式&emsp;cmap – 颜色映射 3.3 准备数据：归一化数值归一化公式 normValue = (value - minvalue)/(maxvalue-minvalue) 123456789def autoNorm(dataSet): minValues = dataSet.min(0) maxValues = dataSet.max(0) ranges = maxValues - minValues normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minValues,(m,1)) normDataSet = dataSet/tile(ranges,(m,1)) return normDataSet, ranges, minValues min()&emsp; python是列优先，所以min(0)是按列求最小值；min(1)是按行求最小值 3.4 测试算法123456789101112131415def datingClassTest(): hoRatio = 0.10 datingDataMat,datingLabels = file2matrix('datingTest2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m*hoRatio) errorCount = 0.0 for i in numTestVecs: classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m],\ datingLabels[numTestVecs:m],3) print("the classifier came back with: %d, the real answer is: %d"\ % classifierResult, datingLabels[i]) if classifierResult != datingLabels: errorCount += 1.0 print("the total error rate is : %f" % errorCount/float(numTestVecs)) 解读hoRatio : 测试集所占的比例；normMat[numTestVecs:m]为训练集特征矩阵，datingLabels[numTestVecs]为训练集类别向量 3.5 使用算法：构建完整可用系统1234567891011def classifyPerson(): resultList = ['not at all','in small doses','in large doses'] percentTats = float(input("Percentage of time spent playing video games?")) ffMiles = float(input("Frequent flier miles earned per year?")) iceCream = float(input("Liters of ice cream consumed per year?")) datingDataMat,datingLabels = file2matrix('datingTestSet2.txt') normMat, range, minVals = autoNorm(datingDataMat) inArr = array([ffMiles,percentTats,iceCream]) classifierResult = classify0((inArr-minVals)/range, normMat, datingLabels,3) print("You will probably like this person:",resultList[classifierResult-1]) 四、手写识别系统4.1 准备数据：将图片数据转换为测试向量12345678def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename) for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0,i*32+j] = int(lineStr[j]) return returnVect TypeError: data type not understood该错误发生在zeros()zeros()在创建一维数组时使用一组括号，创建二维数组时需使用两组括号zeros(1024) zeros((1,1024)) zeros(((1,2,1024))) 4.2 测试算法：使用k-近邻法识别手写数字 解读&emsp;hwLabels – 类别向量&emsp;trainingMat – 特征矩阵&emsp; 123456789101112131415161718192021222324252627282930313233def handwritingClassTets():# 获取目录 hwLabels = [] trainingFileList = listdir('digits/trainingDigits') # 获取指定目录下的文件名 m = len(trainingFileList) # 得到文件数量 trainingMat = zeros((m,1024))# 解析数据，得到类别向量和特征矩阵 # trainingMat -- 特征矩阵 m*1024 # hwLabels -- 类别向量 for i in range(m): fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] # 得到文件名 classNumStr = int(fileStr.split('_')[0]) # 得到文件对应的数字即类别 hwLabels.append(classNumStr) trainingMat[i,:] = img2vector('digits/trainingDigits/%s' % fileNameStr)# 解析测试数据，测试每个文件的类别，分析分类结果 testFileList = listdir('digits/testDigits') errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) vectorUnderTest = img2vector('digits/testDigits/%s' %fileNameStr) classifieResult = classify0(vectorUnderTest,trainingMat,hwLabels,3) print("The classifierResult came back with: %d, the real answer is: %d"\ % (classifieResult,classNumStr)) if classifieResult != classNumStr: errorCount += 1.0 print("The total number of errors is :%d" % errorCount) print("The total error rate is: %f" % (errorCount/float(mTest))) 没有归一化这里使用的文件值为0，1，已经在0～1之间，所以不需要归一化处理（autoNorm()). 五、总结 kNN算法是基于实例的学习，使用该算法时必须有接近实际数据的训练样本数据； kNN算法必须保存全部的数据集，如果训练数据集过大，必须使用大量的存储空间； 必须对数据集中的每一个数据进行距离计算，实际使用会很耗时； 无法给出数据的基础结构信息，因此无法知晓平均实例样本和典型实例样本具有什么特征。 六、补充读文件read() readline() readlines() 的区别 read()read(size)：从文件当前位置起读取size个字节，若无参数size，则读取至整个文件结束，返回字符串对象。 readline()readline()：每次读取一行内容，比较适合大文件，输出为字符串对象。undefined readlines()readlines()：读取整个文件所有行，保存在一个列表（list）变量中，每行作为一个元素，但读取大文件会比较占内存。 linecache模块输出某个文件的第n行import linecachetext = linecache.getline(filename,n)print(text)]]></content>
      <categories>
        <category>Machine-Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode]]></title>
    <url>%2F2019%2F08%2F21%2Fxcode%2F</url>
    <content type="text"><![CDATA[记录使用Xcode过程中遇到的一些坑 一、相对路径问题 配置过程Product —&gt;Scheme —&gt;Edit Scheme —&gt;Options —&gt; Working Directory —&gt;勾选Use custom working directory:并选择工程路径]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pycharm过程中遇到的问题]]></title>
    <url>%2F2019%2F08%2F21%2Fpycharm%2F</url>
    <content type="text"><![CDATA[记录在使用Pycharm时，遇到的一些问题。 一、解决问题1.1 Pycharm 报错 “No module named…”这里提出一个问题，即如何在Pycharm中使用Anaconda部署Python环境 理解几个概念： Python脚本：即.py文件 Python解释器：python.exe ，不同版本的解释器对语法的要求是不同的 Python运行环境：由解释器的版本和第三方库决定 Anaconda的优点： Anaconda可以很方便地管理第三方库，方便管理； 可以创建不同版本的python开发环境，隔离不同的项目要求。 如何在Pycharm中设置Anaconda环境 配置过程打开Pycharm—&gt; Create New Project—&gt; Project Interpreter—&gt; Existing interpreter—&gt; Interpreter—&gt;&gt; …—&gt; Conda Environment —&gt;&gt; users—&gt; anaconda3 —&gt; bin—&gt; python X.X]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法规则]]></title>
    <url>%2F2019%2F08%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 语法说明 一、标题 使用 # 控制 几个 # 代表几级标题 #与文字之间有空格 二、强调1. 加粗在要加粗的字段两侧添加 **这里加粗强调 2. 斜体在要加斜体的字段两侧添加 *这里需要加斜体强调 3. 加粗斜体在字段两侧添加*这里需要 *加粗并斜体*** 4.删除在要删除的字段两侧添加 ~~这句话需要删除~~ 三、列表1、无序列表1234* 项目1* 项目2 * 项目2.1 * 项目2.2 项目1 项目2 项目2.1 项目2.2 2、有序列表1231. 项目11. 项目21. 项目3 项目1 项目2 项目3 项目3.1 项目3.2 四、添加图片 五、链接 可以直接输入网址http://www.baidu.com 可以为网址重命名 1[name](url) 百度 六、引用123俗话说：&gt; 各扫自家门前雪&gt; 休管他人瓦上霜 俗话说： 各扫自家门前雪休管他人瓦上霜 七、分割线1--- 八、行内代码1`&lt;&gt;` 九、代码块9.1 语法高亮添加使用的代码的语言类别 12import numpy as nplist = ['I','Love','U'] 9.2 显示代码行数在语言类别后添加{.line-numbers} &#123;.line-numbers&#125;12import numpy as nplist = ['I','Love','U'] 十、待办事项12- [ ] 阅读文献- [x] 整理笔记 [ ] 阅读文献[x] 整理笔记 十一、表格 First Header Second Header 00 01 10 11 十二、标注 上标12在上标的两侧添加^30^th^ 30^th 下标12在要下标的两侧添加~H_2O H_2O 、CO_3 脚注1[^1] [^1]: Hi, nice to meet you. 高亮1在需要高亮的字符两侧添加== ==marked== Loremdnadkda jdakjd daksdn]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
