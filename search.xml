<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 数据类型]]></title>
    <url>%2F2019%2F08%2F29%2FC-language-foundation%2F</url>
    <content type="text"><![CDATA[变量的存储类型 extern static register auto 数据类型 数组类型 枚举类型 布尔类型 结构体类型 指针类型 自定义类型 运算符 左移&lt;&lt; 右移&gt;&gt; sizeof new delete 练习 冒泡法 Fibonacci数列 一、变量的存储类型变量通常有4中存储类型，分别为extern,static, register, auto。 extern 变量的定义与声明之间的区别&emsp;变量的定义：将为变量分配存储空间；&emsp;变量的声明：告知编译器变量的名称和数据类型 为什么只声明不定义？如果在一个文件中定义一个全局变量，可能需要在其他文件进行访问，在其他文件使用extern可以只声明而不定义全局变量，这样即可共享全局变量。e.g. 在一个文件中定义全局变量var 1int var = 0; 在另一个文件中通过使用extern关键字声明全局变量即可访问变量var。 1extern int var; static 静态变量：分为全局静态变量和局部静态变量。 在函数内部定义一个局部静态变量，则在函数执行后变量的值会保留。 12345void TestStaticVar()&#123; static int var=1; printf("var=%d\n",var++);&#125; 全局静态变量的作用域仅限于当前定义的文件，不能被其他文件使用extern关键字进行访问。 register 表示变量将被放置在CPU的寄存器中，访问寄存器变量要比访问普通变量快得多； register变量只能用于局部变量或作为函数的形式参数，不能用于定义全局变量。 1register int var = 0; auto 静态存储与动态存储&emsp;变量的存储方式分为两种——静态存储和动态存储&emsp;全局变量、静态变量均属于静态存储；&emsp;局部变量属于动态存储。 关键字auto表示变量将被动态存储，默认局部变量均为动态存储，且定义一个全局变量为动态存储是非法的。 二、数据类型2.1 数组类型一维数组数组的定义格式：数组数据类型 数组名称[数组长度]; 1int array[10]; 对数组进行初始化： 可以全部赋值，全部赋值可以省略数组长度 12int array[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;int array[] = &#123;1,2,3,4,5,6,7,8,9,10&#125;; 可以部分赋值 1int array[10] = &#123;1,2,3,4,5&#125;; 可以将其全部初始化为0 1int array[10] = &#123;0&#125;; 二维数组 数组的定义格式：数组数据类型 数组名称[行][列] 1int array2D[3][4]; 数组的初始化： 123int array2D[3][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int array2D[3][4] = &#123;&#123;1,2,3,4&#125;&#125;int array2D[ ][4] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; //可以省略第一位的长度但不能省略第二维的长度。 2.2 枚举类型 使用enum关键字定义枚举类型 提供一组常量的组合 定义时可以为常量提供数值，若没有提供，则默认第一个常量为0，第二个常量为1；若提供数值，则默认常量对应的数值是前一个常量的数值+112345678910111213141516171819202122232425262728293031323334enum InstanceState(CLOSE=1, OPEN, MOUNT=4,UNMOUNT);void OracleOpt(InstanceState state)&#123; switch (state) &#123; case CLOSE: &#123; printf("关闭数据库!\n"); break; &#125; case OPEN: &#123; printf("打开数据库。\n"); break; &#125; case MOUNT: &#123; printf("挂起数据库。\n"); break; &#125; case UNMOUNT: &#123; printf("卸载数据库。\n"); break; &#125; default: break; &#125;&#125;void main()&#123; InstanceState state; OracleOpt(state);&#125; 2.3 布尔类型 布尔类型只有两种取值：true false 布尔类型可以赋值给整型，true 表示1 ，false表示0 整型也可赋值给bool类型，非0为true，0为false 2.4 结构体类型 结构体是一组不同类型的变量的集合，使用关键字struct声明一个结构体类型 12345678const int MAX_CHAR = 128;struct Student&#123; char name[MAX_CHAR]; char sex[MAX_CHAR]; unsigned int age; char addr[MAX_CHAR];&#125;; //定义最后一定记得加; 定义结构体变量 12struct Student stdnt;Student stdnt; 直接在定义结构体类型时给出定义的变量 1234567struct Student // 若变量只需定义一次，结构体名称Student可以省略&#123; char name[MAX_CHAR]; char sex[MAX_CHAR]; unsigned int age; char addr[MAX_CHAR];&#125;stdnt; 2.5 指针类型 定义指针 数据类型 指针变量名1234int *pi; // 定义整型指针变量int ivar = 10; // 定义整型变量pi = &amp;ivar; // 取ivar的地址赋给pi// int *pi = &amp;ivar; 取值* 取地址&amp;int var =10;int *pi;pi=&var;*pi=8; // 可以修改变量的值 定义指针数组1int *parray[5]; 指针数组中的每一个值都是指针。 使用const关键字定义指针12345678// 不能修改指针指向的变量的值，但可以修改指针指向的地址const int *pvar=&amp;var;// 不能修改指针指向的地址，但可以修改指针指向的数据int const *pvar=&amp;var;// 既不能修改指针指向的地址，也不能修改指针指向的数据const int const *pvar=&amp;var; 2.6 自定义类型使用关键字typedef自定义数据类型，为已存在的数据类型定义一个新的名称 12// typedef 数据类型 新的名称;typedef unsigned int UINT; 三、运算符3.1 左移运算符 &lt;&lt;1int iret =10 &lt;&lt;2; 3.2 右移运算符 &gt;&gt;1int iret=10 &gt;&gt;2; 3.3 sizeof运算符用于返回变量所占的字节数 用于返回变量、对象或数据类型的字节长度 123int ivar=10;int size=sizeof(ivar); // 获取变量ivar的大小int typesize=sizeof(int); //获取int类型的大小 用于确定数组的大小 1234int iarray[5] = &#123;1,2,3,4,5&#125;;int arraysize = sizeof(iarray); // 获取整型数组的大小，为20char carray[] ="Hello";int carray=sizeof(carray);// 为6，字符串常量系统自动加"\0"作为结束标记 用于确定指针的大小对于32位的操作系统，无论指针指向是何种类型或指向何种类型的数据，指针的长度均为4，因为指针是按32位来寻址的，长度位4 byte。对于64位的操作系统，则指针长度位8. 3.4 new 和 delete运算符 数据存储方式：堆存储、栈存储&emsp;堆存储：通常同于存储占用空间大、生命周期长的数据，e.g.静态变量和全局变量等。&emsp;栈存储：通常用于存储占用空间小、生命周期短的数据，e.g.局部变量和函数参数等。 除了全局变量和静态变量，用户可以使用关键字new开辟堆存储。 1234int *pvar = new int; //定义一个整型指针，调用new在堆中为其分配内存*pvar = 10; //设置指针的值printf("pvar= %d\n",*pvar); //输出指针的值delete pvar; //释放指针指向的堆空间 使用new分配堆空间时，对其进行初始化 1int *pvar = new int(10); //pvar指向的数据位10 使用new为数组动态分配存储空间 1int *pvar = new int[10]; //定义一个整型指针，调用new在堆中分配数组空间，将首地址赋值为指针pvar。 使用new运算符为数组分配空间时，不能对数组进行初始化（除非变量是一个对象，并且对象的类提供了默认的构造函数）。在释放new为数组分配的空间时，需要使用delete[]来释放。 12int *pvar = new int[5];delete [] pvar; 四、练习4.1 不使用库函数，复制源字符串到目标字符串，实现strcpy()的功能。12345string copyStr(string a)&#123; string b = a; return b;&#125; 4.2 接收一个字符串作为输入参数，将其逆序输出123456789void reverseStr(string a)&#123; int len = a.length(); for(;len&gt;=0;len--) &#123; cout &lt;&lt; a[len]; &#125; cout &lt;&lt; endl;&#125; 求字符串的长度&emsp; str.length() str.size() 均可直接得到字符串的长度&emsp; 若将字符串保存在char数组中，则最后一位系统默认位’\0’&emsp; 函数strlen()，求字符串的长度 4.3 使用冒泡法对数组进行排序1234567891011121314151617181920void Bubbling(int a[],int len)&#123; int i,j,t = 0; for(i,i&lt;len-1;i++) &#123; for(j;j&lt;len-1-i;j++) &#123; //从小到大 if(a[j]&gt;a[j+1]) &#123; t = a[j]; a[j] = a[j+1]; a[j+1] = a[j]; &#125; &#125; &#125; for(int k=0;k&lt;len;k++) cout &lt;&lt; a[k]; cout &lt;&lt;endl;&#125; 求数组的长度数组的长度：sizeof(数组地址)/sizeof（数组数据类型）但是这里有一个点没搞明白，为什么不可以在函数内求数组的长度呢，而要将数组的长度当作一个参数？？测试了一下在函数内求数组的长度，求的结果是不对的…. 排序算法：冒泡法如果数组的长度是len,则我们需要排（len-1)趟，第i趟排（len-1-i)次。 4.4 使用数组输出Fibonacci数列（又称，斐波那契数列、黄金分割数列、兔子数列）。Fibonacci数列的特点：F(1)=1,F(2)=1,F(n)=F(n-1)+F(n-2)(n&gt;=3,n∊N*) 12345678910111213141516void printFibonacci()&#123; int i; int f[20]=&#123;1,1&#125;; for(i=2;i&lt;20;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; for(i=0;i&lt;20;i++) &#123; if(i%5==0) printf("\n"); printf("%8d",f[i]); &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语句]]></title>
    <url>%2F2019%2F08%2F29%2FCppStatement%2F</url>
    <content type="text"><![CDATA[C++ 语句构成 使用分支语句设计逻辑条件判断 掌握各种循环语句在程序开发中的应用 应用跳转语句改变代码的执行顺序 一、复合语句 注意复合语句中变量的定义域在复合语句中定义的变量，其作用域范围在当前定义变量处到复合语句结束。 123456789int ivar = 1;&#123; int ivar = 1; &#123; ivar = 2; printf("ivar = %d\n",ivar); //ivar = 2 &#125;&#125;printf("ivar = %d\n",ivar); //ivar = 1 二、分支语句if 语句if 语句格式 123456if(表达式) 语句;else if(表达式) 语句;else 语句; switch语句switch 语句格式 123456789switch(表达式/变量名)&#123; case 常量1: break; case 常量2: break; default: break;&#125; 1234567891011121314151617int main()&#123; enum State &#123;CLOSE,OPEN&#125;; State s =CLOSE; switch(s) &#123; case CLOSE: printf("Close!\n"); break; case OPEN: printf("Open!\n"); break; default: break; &#125; return 0;&#125; 注意⚠️这里记住 枚举型如何定义？没有=，没有‘’switch 语句用{}如果switch语句中没有break;当表达式与常量相匹配时，将执行当前case语句代码并继续向下执行case语句代码直到遇到break语句或switch语句结束。case 语句块千万不要忘记加break语句 break 与continue 语句的区别和用法&emsp;break 语句用于跳出循环；&emsp;continue 语句用于结束本轮循环。 三、循环语句for( ; ; )while(){ }do{} while; (分号;不要忘记）四、跳转语句4.1 goto语句goto语句是无条件跳转语句，用于改变代码执行的顺序。使用goto语句时，CPU需要不停地跳转，效率比较低，在开发时应慎用goto语句。 12345678910int main()&#123; int i, sum = 0; label: i++; sum += i; if(i&lt;100) goto label; printf("sum = %d\n",sum);&#125; 在使用goto语句时应注意label的使用，其后不能紧跟 } . 123456int ivar = 0;&#123; //其他操作 label:; //label之后不能紧跟&#125; &#125; 在使用goto语句时应注意goto语句不能越过复合语句之外的变量定义的语句。 1234567891011goto lable_1;int i =0; //不合法，goto语句不能越过label_1: printf("goto\n");goto label_2&#123; int i = 0; //合法&#125;label_2: printf("goto\n"); 4.2 return 语句return 语句用于跳出退出当前函数，当程序在当前函数中执行时，return语句将推出当前函数的执行，返回到函数调用处，继续执行；若当前函数为主函数，则退出应用程序。 12345678910bool ValidateData( const int price)&#123; if (price&gt;1000||price&lt;10) &#123; printf("价格错误！\n"); return false; &#125; printf("验证通过。\n"); return true;&#125; 使用return语句提前结束函数时，需要注意代码之前在堆中分配了内存，在return 语句之前应释放内存，防止内存泄漏。 123456789101112131415161718void ReturnDemo(int min)&#123; int* parr = new int[5]; for(int i=0;i&lt;5;i++) &#123; parr[i] = i; &#125; if(parr[0]&gt;min) &#123; delete[] parr; return; &#125; else &#123; parr[0] = min; &#125; delete[] parr;&#125; 4.3 exit语句exit()是一个用于退出当前调用进程的函数，包含一个整型参数，标识进程退出代码。 1234567void ExitDemo(const int res)&#123; if(res == 0) exit(res); //结束应用程序 else return;&#125; 五、练习5.1 判断是否为素数什么是质数？质数除1和其本身之外没有其他约数。 123456789// 定义法,时间复杂度O(n)bool isPrime_1(int num)&#123; int tmp=num-1; for(int i=2;i&lt;=tmp;i++) if(num%i==0) return 0; return 1;&#125; 一个数若可以进行因数分解，则分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n),所以在判断时不需要遍历至(n-1),遍历至sqrt(n)即可。时间复杂度O(sqrt(n))。 123456789101112131415161718192021222324252627282930#include &lt;math.h&gt;bool isPrime_2(int num)&#123; int tmp = sqrt(num); for(int i=2;i&lt;=tmp;i++) &#123; if(num%i==0) return 0; &#125; return 1;&#125;关于质数的一个规律：大于等于5的质数一定和6的倍数相邻。证明：令x&gt;=1,大于等于5的自然数可以表示为：6i-1,6i,6i+1,6i+2,6i+3,6i+4,6i+5其中，6i一定是6的倍数，6i+2,6i+4一定是2的倍数，6i+3一定是3的倍数，均不是素数，所以只需要考虑6i-1和6i+5，判断其不是5或7，11或13，17或19......的倍数即可。```Cbool isPrime_3(int num)&#123; //先输出小于5的质数 if(num==2 || num==3) return 1; //不在6的倍数两侧的数一定不是质数 if(num%6!=5 &amp;&amp; num%6!=1) return 0; //在6的倍数两侧也不一定是质数 int tmp = sqrt(num); for(int i=5;i&lt;=tmp;i+=6) if(num%i==0 || num%(i+2)==0) return 0; return 1;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++语句]]></title>
    <url>%2F2019%2F08%2F29%2FCpp%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[C++ 语句构成 使用分支语句设计逻辑条件判断 掌握各种循环语句在程序开发中的应用 应用跳转语句改变代码的执行顺序 一、复合语句 注意复合语句中变量的定义域在复合语句中定义的变量，其作用域范围在当前定义变量处到复合语句结束。 123456789int ivar = 1;&#123; int ivar = 1; &#123; ivar = 2; printf("ivar = %d\n",ivar); //ivar = 2 &#125;&#125;printf("ivar = %d\n",ivar); //ivar = 1 二、分支语句if 语句if 语句格式 123456if(表达式) 语句;else if(表达式) 语句;else 语句; switch语句switch 语句格式 123456789switch(表达式/变量名)&#123; case 常量1: break; case 常量2: break; default: break;&#125; 1234567891011121314151617int main()&#123; enum State &#123;CLOSE,OPEN&#125;; State s =CLOSE; switch(s) &#123; case CLOSE: printf("Close!\n"); break; case OPEN: printf("Open!\n"); break; default: break; &#125; return 0;&#125; 注意⚠️这里记住 枚举型如何定义？没有=，没有‘’switch 语句用{}如果switch语句中没有break;当表达式与常量相匹配时，将执行当前case语句代码并继续向下执行case语句代码直到遇到break语句或switch语句结束。case 语句块千万不要忘记加break语句 break 与continue 语句的区别和用法&emsp;break 语句用于跳出循环；&emsp;continue 语句用于结束本轮循环。 三、循环语句for( ; ; )while(){ }do{} while; (分号;不要忘记）四、跳转语句4.1 goto语句goto语句是无条件跳转语句，用于改变代码执行的顺序。使用goto语句时，CPU需要不停地跳转，效率比较低，在开发时应慎用goto语句。 12345678910int main()&#123; int i, sum = 0; label: i++; sum += i; if(i&lt;100) goto label; printf("sum = %d\n",sum);&#125; 在使用goto语句时应注意label的使用，其后不能紧跟 } . 123456int ivar = 0;&#123; //其他操作 label:; //label之后不能紧跟&#125; &#125; 在使用goto语句时应注意goto语句不能越过复合语句之外的变量定义的语句。 1234567891011goto lable_1;int i =0; //不合法，goto语句不能越过label_1: printf("goto\n");goto label_2&#123; int i = 0; //合法&#125;label_2: printf("goto\n"); 4.2 return 语句return 语句用于跳出退出当前函数，当程序在当前函数中执行时，return语句将推出当前函数的执行，返回到函数调用处，继续执行；若当前函数为主函数，则退出应用程序。 12345678910bool ValidateData( const int price)&#123; if (price&gt;1000||price&lt;10) &#123; printf("价格错误！\n"); return false; &#125; printf("验证通过。\n"); return true;&#125; 使用return语句提前结束函数时，需要注意代码之前在堆中分配了内存，在return 语句之前应释放内存，防止内存泄漏。 123456789101112131415161718void ReturnDemo(int min)&#123; int* parr = new int[5]; for(int i=0;i&lt;5;i++) &#123; parr[i] = i; &#125; if(parr[0]&gt;min) &#123; delete[] parr; return; &#125; else &#123; parr[0] = min; &#125; delete[] parr;&#125; 4.3 exit语句exit()是一个用于退出当前调用进程的函数，包含一个整型参数，标识进程退出代码。 1234567void ExitDemo(const int res)&#123; if(res == 0) exit(res); //结束应用程序 else return;&#125; 五、练习5.1 判断是否为素数什么是质数？质数除1和其本身之外没有其他约数。 123456789// 定义法,时间复杂度O(n)bool isPrime_1(int num)&#123; int tmp=num-1; for(int i=2;i&lt;=tmp;i++) if(num%i==0) return 0; return 1;&#125; 一个数若可以进行因数分解，则分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n),所以在判断时不需要遍历至(n-1),遍历至sqrt(n)即可。时间复杂度O(sqrt(n))。 123456789101112131415161718192021222324252627282930#include &lt;math.h&gt;bool isPrime_2(int num)&#123; int tmp = sqrt(num); for(int i=2;i&lt;=tmp;i++) &#123; if(num%i==0) return 0; &#125; return 1;&#125;关于质数的一个规律：大于等于5的质数一定和6的倍数相邻。证明：令x&gt;=1,大于等于5的自然数可以表示为：6i-1,6i,6i+1,6i+2,6i+3,6i+4,6i+5其中，6i一定是6的倍数，6i+2,6i+4一定是2的倍数，6i+3一定是3的倍数，均不是素数，所以只需要考虑6i-1和6i+5，判断其不是5或7，11或13，17或19......的倍数即可。```Cbool isPrime_3(int num)&#123; //先输出小于5的质数 if(num==2 || num==3) return 1; //不在6的倍数两侧的数一定不是质数 if(num%6!=5 &amp;&amp; num%6!=1) return 0; //在6的倍数两侧也不一定是质数 int tmp = sqrt(num); for(int i=5;i&lt;=tmp;i+=6) if(num%i==0 || num%(i+2)==0) return 0; return 1;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战k-近邻算法]]></title>
    <url>%2F2019%2F08%2F25%2FkNN%2F</url>
    <content type="text"><![CDATA[介绍什么是k-近邻算法 每一个函数的作用及包含的Python语法 记录程序调试和运行结果 一、什么是k-近邻算法计算测试样本与训练样本集中每个实例之间的距离，从小到大排序后取前k个实例，通过查看前k个实例的类别百分比确定测试样本的类别。 优点 精度高，对异常值不敏感，无数据输入假定。{%btn #url,缺点,,title%} 计算复杂度高，空间复杂度高适用范围 数值型、标称型 标称型在有限的数据中取值，例如，bool型（包含True和False）、枚举型 二、代码分析2.1 使用Python导入数据123456from numpy import *import operatordef creatDataSet(): group = array([[1,1],[1,1.1],[0,0],[0,0.1]]) labels = ['A','A','B','B'] return group, labels 引入了两个模块，Numpy便于进行数据处理；operator运算符模块。 2.2 kNN算法伪代码对未知类别属性的数据集中的每个点依次执行： 计算已知类别数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点距离最小的k个点； 确定前k个点所在类别的出现频率 返回前k个点出现频率最高的类别作为当前点的预测分类 代码输入：&emsp;&emsp;inX – 用于分类的输入向量&emsp;&emsp;dataSet– 输入训练样本集&emsp;&emsp;labels – 输入训练样本类别&emsp;&emsp;k – 选择的最近邻点数 1234567891011121314151617def classify0(inX, dataSet, labels, k): # 计算距离 dataSetSize = dataSet.shape[0] diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 # 选择距离最小的k个点 sortedDistIndicies = distances.argsort() # 返回数组值从小到大的索引值 classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] #get的用法 get(key,default) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] tile()numpy.tile(A, reps): A 为待输入数组，reps决定了A重复的次数。 sum()axis = 0，按列相加；axis = 1，按行相加 argsort()返回数组值从小到大的索引值 dict.get()dict.get(key,default=None) , 返回指定键的值，若值不存在则返回默认值。 dict.items()返回可遍历的元组数组。undefined sorted()sorted(iterable, cmp=None, key=None, reverse=False)iterable – 可迭代对象cmp – 比较函数key – 用来进行比较的元素，只有一个参数，具体的函数的参数应取自可迭代对象中，指定可迭代对象中的一个元素来进行排序reverse – 指定排序规则，reverse=True 降序， reverse=False 升序（默认） operator.itemgetter()用于获取对象指定维的数据。sorted(iterable, key = operator.itemgetter(1)) 即根据对象的第二维进行排序。 2.3 如何测试分类器错误率：分类器给出错误结果的次数/测试执行的总次数常用来评估分类器在某个数据集上的执行效果。 三、实例：使用k-近邻算法改进约会网站的配对效果3.1 将文本数据转换为Numpy的解析程序返回值：&emsp;returnMat – 特征矩阵&emsp;classLabelVector – 类别向量 1234567891011121314def file2matrix(filename): fr = open(filename) arrayOLines = fr.readlines() numberOfLines = len(arrayLines) returnMat = zeros((numberOfLines,3)) classLabelVector = [] index = 0 for line in arrayOLines: line = line.strip() listFromLine = line.split('\t') returnMat[index,:] = listFromLine[0:3] classLabelVector.append(int(listFromLine[-1])) index += 1 return returnMat, classLabelVector 解读open(filenam):打开指定的文件readlines():按行读取文本strip():删除开头和结尾的空格与换行符str.split(str=””,num= :根据指定的分隔符对字符串进行切片，如果参数num有指定值，则分隔num+1个字符串。&emsp;&emsp; str – 分隔符，默认为所有空字符，包含空格、换行（\n）、制表(\t)&emsp;&emsp; num – 分割次数，默认为-1，即分隔所有。 3.2 分析数据：使用Matplotlib绘制散点图123456import matplotlibimport matplotlib.pyplot as pltfig = plt.figure()ax = fig.add_subplot(111)ax.scatter(datingDataMat[:,1], datingDataMat[:,2])plt.show() 解读matplotlib.pyplot.scatter(x,y,s,c,marker,cmap)&emsp;x,y – 坐标数据&emsp;s – 数据点的大小&emsp;c – 数据点的颜色&emsp;marker – 数据点的样式&emsp;cmap – 颜色映射 3.3 准备数据：归一化数值归一化公式 normValue = (value - minvalue)/(maxvalue-minvalue) 123456789def autoNorm(dataSet): minValues = dataSet.min(0) maxValues = dataSet.max(0) ranges = maxValues - minValues normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minValues,(m,1)) normDataSet = dataSet/tile(ranges,(m,1)) return normDataSet, ranges, minValues min()&emsp; python是列优先，所以min(0)是按列求最小值；min(1)是按行求最小值 3.4 测试算法123456789101112131415def datingClassTest(): hoRatio = 0.10 datingDataMat,datingLabels = file2matrix('datingTest2.txt') normMat, ranges, minVals = autoNorm(datingDataMat) m = normMat.shape[0] numTestVecs = int(m*hoRatio) errorCount = 0.0 for i in numTestVecs: classifierResult = classify0(normMat[i,:],normMat[numTestVecs:m],\ datingLabels[numTestVecs:m],3) print("the classifier came back with: %d, the real answer is: %d"\ % classifierResult, datingLabels[i]) if classifierResult != datingLabels: errorCount += 1.0 print("the total error rate is : %f" % errorCount/float(numTestVecs)) 解读hoRatio : 测试集所占的比例；normMat[numTestVecs:m]为训练集特征矩阵，datingLabels[numTestVecs]为训练集类别向量 3.5 使用算法：构建完整可用系统1234567891011def classifyPerson(): resultList = ['not at all','in small doses','in large doses'] percentTats = float(input("Percentage of time spent playing video games?")) ffMiles = float(input("Frequent flier miles earned per year?")) iceCream = float(input("Liters of ice cream consumed per year?")) datingDataMat,datingLabels = file2matrix('datingTestSet2.txt') normMat, range, minVals = autoNorm(datingDataMat) inArr = array([ffMiles,percentTats,iceCream]) classifierResult = classify0((inArr-minVals)/range, normMat, datingLabels,3) print("You will probably like this person:",resultList[classifierResult-1]) 四、手写识别系统4.1 准备数据：将图片数据转换为测试向量12345678def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename) for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0,i*32+j] = int(lineStr[j]) return returnVect TypeError: data type not understood该错误发生在zeros()zeros()在创建一维数组时使用一组括号，创建二维数组时需使用两组括号zeros(1024) zeros((1,1024)) zeros(((1,2,1024))) 4.2 测试算法：使用k-近邻法识别手写数字 解读&emsp;hwLabels – 类别向量&emsp;trainingMat – 特征矩阵&emsp; 123456789101112131415161718192021222324252627282930313233def handwritingClassTets():# 获取目录 hwLabels = [] trainingFileList = listdir('digits/trainingDigits') # 获取指定目录下的文件名 m = len(trainingFileList) # 得到文件数量 trainingMat = zeros((m,1024))# 解析数据，得到类别向量和特征矩阵 # trainingMat -- 特征矩阵 m*1024 # hwLabels -- 类别向量 for i in range(m): fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] # 得到文件名 classNumStr = int(fileStr.split('_')[0]) # 得到文件对应的数字即类别 hwLabels.append(classNumStr) trainingMat[i,:] = img2vector('digits/trainingDigits/%s' % fileNameStr)# 解析测试数据，测试每个文件的类别，分析分类结果 testFileList = listdir('digits/testDigits') errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] classNumStr = int(fileStr.split('_')[0]) vectorUnderTest = img2vector('digits/testDigits/%s' %fileNameStr) classifieResult = classify0(vectorUnderTest,trainingMat,hwLabels,3) print("The classifierResult came back with: %d, the real answer is: %d"\ % (classifieResult,classNumStr)) if classifieResult != classNumStr: errorCount += 1.0 print("The total number of errors is :%d" % errorCount) print("The total error rate is: %f" % (errorCount/float(mTest))) 没有归一化这里使用的文件值为0，1，已经在0～1之间，所以不需要归一化处理（autoNorm()). 五、总结 kNN算法是基于实例的学习，使用该算法时必须有接近实际数据的训练样本数据； kNN算法必须保存全部的数据集，如果训练数据集过大，必须使用大量的存储空间； 必须对数据集中的每一个数据进行距离计算，实际使用会很耗时； 无法给出数据的基础结构信息，因此无法知晓平均实例样本和典型实例样本具有什么特征。 六、补充读文件read() readline() readlines() 的区别 read()read(size)：从文件当前位置起读取size个字节，若无参数size，则读取至整个文件结束，返回字符串对象。 readline()readline()：每次读取一行内容，比较适合大文件，输出为字符串对象。undefined readlines()readlines()：读取整个文件所有行，保存在一个列表（list）变量中，每行作为一个元素，但读取大文件会比较占内存。 linecache模块输出某个文件的第n行import linecachetext = linecache.getline(filename,n)print(text)]]></content>
      <categories>
        <category>Machine-Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode]]></title>
    <url>%2F2019%2F08%2F21%2Fxcode%2F</url>
    <content type="text"><![CDATA[记录使用Xcode过程中遇到的一些坑 一、相对路径问题 配置过程Product —&gt;Scheme —&gt;Edit Scheme —&gt;Options —&gt; Working Directory —&gt;勾选Use custom working directory:并选择工程路径]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Pycharm过程中遇到的问题]]></title>
    <url>%2F2019%2F08%2F21%2Fpycharm%2F</url>
    <content type="text"><![CDATA[记录在使用Pycharm时，遇到的一些问题。 一、解决问题1.1 Pycharm 报错 “No module named…”这里提出一个问题，即如何在Pycharm中使用Anaconda部署Python环境 理解几个概念： Python脚本：即.py文件 Python解释器：python.exe ，不同版本的解释器对语法的要求是不同的 Python运行环境：由解释器的版本和第三方库决定 Anaconda的优点： Anaconda可以很方便地管理第三方库，方便管理； 可以创建不同版本的python开发环境，隔离不同的项目要求。 如何在Pycharm中设置Anaconda环境 配置过程打开Pycharm—&gt; Create New Project—&gt; Project Interpreter—&gt; Existing interpreter—&gt; Interpreter—&gt;&gt; …—&gt; Conda Environment —&gt;&gt; users—&gt; anaconda3 —&gt; bin—&gt; python X.X]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法规则]]></title>
    <url>%2F2019%2F08%2F20%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[Markdown 语法说明 一、标题 使用 # 控制 几个 # 代表几级标题 #与文字之间有空格 二、强调1. 加粗在要加粗的字段两侧添加 **这里加粗强调 2. 斜体在要加斜体的字段两侧添加 *这里需要加斜体强调 3. 加粗斜体在字段两侧添加*这里需要 *加粗并斜体*** 4.删除在要删除的字段两侧添加 ~~这句话需要删除~~ 三、列表1、无序列表1234* 项目1* 项目2 * 项目2.1 * 项目2.2 项目1 项目2 项目2.1 项目2.2 2、有序列表1231. 项目11. 项目21. 项目3 项目1 项目2 项目3 项目3.1 项目3.2 四、添加图片 五、链接 可以直接输入网址http://www.baidu.com 可以为网址重命名 1[name](url) 百度 六、引用123俗话说：&gt; 各扫自家门前雪&gt; 休管他人瓦上霜 俗话说： 各扫自家门前雪休管他人瓦上霜 七、分割线1--- 八、行内代码1`&lt;&gt;` 九、代码块9.1 语法高亮添加使用的代码的语言类别 12import numpy as nplist = ['I','Love','U'] 9.2 显示代码行数在语言类别后添加{.line-numbers} &#123;.line-numbers&#125;12import numpy as nplist = ['I','Love','U'] 十、待办事项12- [ ] 阅读文献- [x] 整理笔记 [ ] 阅读文献[x] 整理笔记 十一、表格 First Header Second Header 00 01 10 11 十二、标注 上标12在上标的两侧添加^30^th^ 30^th 下标12在要下标的两侧添加~H_2O H_2O 、CO_3 脚注1[^1] [^1]: Hi, nice to meet you. 高亮1在需要高亮的字符两侧添加== ==marked== Loremdnadkda jdakjd daksdn]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
